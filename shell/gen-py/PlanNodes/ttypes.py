#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import CatalogObjects.ttypes
import ExecStats.ttypes
import Exprs.ttypes
import Types.ttypes
import ExternalDataSource.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TPlanNodeType:
  HDFS_SCAN_NODE = 0
  HBASE_SCAN_NODE = 1
  HASH_JOIN_NODE = 2
  AGGREGATION_NODE = 3
  SORT_NODE = 4
  EMPTY_SET_NODE = 5
  EXCHANGE_NODE = 6
  UNION_NODE = 7
  SELECT_NODE = 8
  NESTED_LOOP_JOIN_NODE = 9
  DATA_SOURCE_NODE = 10
  ANALYTIC_EVAL_NODE = 11
  SINGULAR_ROW_SRC_NODE = 12
  UNNEST_NODE = 13
  SUBPLAN_NODE = 14
  KUDU_SCAN_NODE = 15

  _VALUES_TO_NAMES = {
    0: "HDFS_SCAN_NODE",
    1: "HBASE_SCAN_NODE",
    2: "HASH_JOIN_NODE",
    3: "AGGREGATION_NODE",
    4: "SORT_NODE",
    5: "EMPTY_SET_NODE",
    6: "EXCHANGE_NODE",
    7: "UNION_NODE",
    8: "SELECT_NODE",
    9: "NESTED_LOOP_JOIN_NODE",
    10: "DATA_SOURCE_NODE",
    11: "ANALYTIC_EVAL_NODE",
    12: "SINGULAR_ROW_SRC_NODE",
    13: "UNNEST_NODE",
    14: "SUBPLAN_NODE",
    15: "KUDU_SCAN_NODE",
  }

  _NAMES_TO_VALUES = {
    "HDFS_SCAN_NODE": 0,
    "HBASE_SCAN_NODE": 1,
    "HASH_JOIN_NODE": 2,
    "AGGREGATION_NODE": 3,
    "SORT_NODE": 4,
    "EMPTY_SET_NODE": 5,
    "EXCHANGE_NODE": 6,
    "UNION_NODE": 7,
    "SELECT_NODE": 8,
    "NESTED_LOOP_JOIN_NODE": 9,
    "DATA_SOURCE_NODE": 10,
    "ANALYTIC_EVAL_NODE": 11,
    "SINGULAR_ROW_SRC_NODE": 12,
    "UNNEST_NODE": 13,
    "SUBPLAN_NODE": 14,
    "KUDU_SCAN_NODE": 15,
  }

class TExecNodePhase:
  PREPARE = 0
  PREPARE_SCANNER = 1
  OPEN = 2
  GETNEXT = 3
  GETNEXT_SCANNER = 4
  CLOSE = 5
  INVALID = 6

  _VALUES_TO_NAMES = {
    0: "PREPARE",
    1: "PREPARE_SCANNER",
    2: "OPEN",
    3: "GETNEXT",
    4: "GETNEXT_SCANNER",
    5: "CLOSE",
    6: "INVALID",
  }

  _NAMES_TO_VALUES = {
    "PREPARE": 0,
    "PREPARE_SCANNER": 1,
    "OPEN": 2,
    "GETNEXT": 3,
    "GETNEXT_SCANNER": 4,
    "CLOSE": 5,
    "INVALID": 6,
  }

class TDebugAction:
  WAIT = 0
  FAIL = 1
  INJECT_ERROR_LOG = 2
  MEM_LIMIT_EXCEEDED = 3
  SET_DENY_RESERVATION_PROBABILITY = 4

  _VALUES_TO_NAMES = {
    0: "WAIT",
    1: "FAIL",
    2: "INJECT_ERROR_LOG",
    3: "MEM_LIMIT_EXCEEDED",
    4: "SET_DENY_RESERVATION_PROBABILITY",
  }

  _NAMES_TO_VALUES = {
    "WAIT": 0,
    "FAIL": 1,
    "INJECT_ERROR_LOG": 2,
    "MEM_LIMIT_EXCEEDED": 3,
    "SET_DENY_RESERVATION_PROBABILITY": 4,
  }

class TReplicaPreference:
  CACHE_LOCAL = 0
  CACHE_RACK = 1
  DISK_LOCAL = 2
  DISK_RACK = 3
  REMOTE = 4

  _VALUES_TO_NAMES = {
    0: "CACHE_LOCAL",
    1: "CACHE_RACK",
    2: "DISK_LOCAL",
    3: "DISK_RACK",
    4: "REMOTE",
  }

  _NAMES_TO_VALUES = {
    "CACHE_LOCAL": 0,
    "CACHE_RACK": 1,
    "DISK_LOCAL": 2,
    "DISK_RACK": 3,
    "REMOTE": 4,
  }

class TRuntimeFilterType:
  BLOOM = 0
  MIN_MAX = 1

  _VALUES_TO_NAMES = {
    0: "BLOOM",
    1: "MIN_MAX",
  }

  _NAMES_TO_VALUES = {
    "BLOOM": 0,
    "MIN_MAX": 1,
  }

class TJoinOp:
  INNER_JOIN = 0
  LEFT_OUTER_JOIN = 1
  LEFT_SEMI_JOIN = 2
  LEFT_ANTI_JOIN = 3
  NULL_AWARE_LEFT_ANTI_JOIN = 4
  RIGHT_OUTER_JOIN = 5
  RIGHT_SEMI_JOIN = 6
  RIGHT_ANTI_JOIN = 7
  FULL_OUTER_JOIN = 8
  CROSS_JOIN = 9

  _VALUES_TO_NAMES = {
    0: "INNER_JOIN",
    1: "LEFT_OUTER_JOIN",
    2: "LEFT_SEMI_JOIN",
    3: "LEFT_ANTI_JOIN",
    4: "NULL_AWARE_LEFT_ANTI_JOIN",
    5: "RIGHT_OUTER_JOIN",
    6: "RIGHT_SEMI_JOIN",
    7: "RIGHT_ANTI_JOIN",
    8: "FULL_OUTER_JOIN",
    9: "CROSS_JOIN",
  }

  _NAMES_TO_VALUES = {
    "INNER_JOIN": 0,
    "LEFT_OUTER_JOIN": 1,
    "LEFT_SEMI_JOIN": 2,
    "LEFT_ANTI_JOIN": 3,
    "NULL_AWARE_LEFT_ANTI_JOIN": 4,
    "RIGHT_OUTER_JOIN": 5,
    "RIGHT_SEMI_JOIN": 6,
    "RIGHT_ANTI_JOIN": 7,
    "FULL_OUTER_JOIN": 8,
    "CROSS_JOIN": 9,
  }

class TSortType:
  TOTAL = 0
  TOPN = 1
  PARTIAL = 2

  _VALUES_TO_NAMES = {
    0: "TOTAL",
    1: "TOPN",
    2: "PARTIAL",
  }

  _NAMES_TO_VALUES = {
    "TOTAL": 0,
    "TOPN": 1,
    "PARTIAL": 2,
  }

class TAnalyticWindowType:
  RANGE = 0
  ROWS = 1

  _VALUES_TO_NAMES = {
    0: "RANGE",
    1: "ROWS",
  }

  _NAMES_TO_VALUES = {
    "RANGE": 0,
    "ROWS": 1,
  }

class TAnalyticWindowBoundaryType:
  CURRENT_ROW = 0
  PRECEDING = 1
  FOLLOWING = 2

  _VALUES_TO_NAMES = {
    0: "CURRENT_ROW",
    1: "PRECEDING",
    2: "FOLLOWING",
  }

  _NAMES_TO_VALUES = {
    "CURRENT_ROW": 0,
    "PRECEDING": 1,
    "FOLLOWING": 2,
  }


class TRuntimeFilterTargetDesc:
  """
  Attributes:
   - node_id
   - target_expr
   - is_bound_by_partition_columns
   - target_expr_slotids
   - is_local_target
   - kudu_col_name
   - kudu_col_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'node_id', None, None, ), # 1
    (2, TType.STRUCT, 'target_expr', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'is_bound_by_partition_columns', None, None, ), # 3
    (4, TType.LIST, 'target_expr_slotids', (TType.I32,None), None, ), # 4
    (5, TType.BOOL, 'is_local_target', None, None, ), # 5
    (6, TType.STRING, 'kudu_col_name', None, None, ), # 6
    (7, TType.STRUCT, 'kudu_col_type', (Types.ttypes.TColumnType, Types.ttypes.TColumnType.thrift_spec), None, ), # 7
  )

  def __init__(self, node_id=None, target_expr=None, is_bound_by_partition_columns=None, target_expr_slotids=None, is_local_target=None, kudu_col_name=None, kudu_col_type=None,):
    self.node_id = node_id
    self.target_expr = target_expr
    self.is_bound_by_partition_columns = is_bound_by_partition_columns
    self.target_expr_slotids = target_expr_slotids
    self.is_local_target = is_local_target
    self.kudu_col_name = kudu_col_name
    self.kudu_col_type = kudu_col_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.node_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.target_expr = Exprs.ttypes.TExpr()
          self.target_expr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_bound_by_partition_columns = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.target_expr_slotids = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32();
            self.target_expr_slotids.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.is_local_target = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.kudu_col_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.kudu_col_type = Types.ttypes.TColumnType()
          self.kudu_col_type.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TRuntimeFilterTargetDesc')
    if self.node_id is not None:
      oprot.writeFieldBegin('node_id', TType.I32, 1)
      oprot.writeI32(self.node_id)
      oprot.writeFieldEnd()
    if self.target_expr is not None:
      oprot.writeFieldBegin('target_expr', TType.STRUCT, 2)
      self.target_expr.write(oprot)
      oprot.writeFieldEnd()
    if self.is_bound_by_partition_columns is not None:
      oprot.writeFieldBegin('is_bound_by_partition_columns', TType.BOOL, 3)
      oprot.writeBool(self.is_bound_by_partition_columns)
      oprot.writeFieldEnd()
    if self.target_expr_slotids is not None:
      oprot.writeFieldBegin('target_expr_slotids', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.target_expr_slotids))
      for iter6 in self.target_expr_slotids:
        oprot.writeI32(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.is_local_target is not None:
      oprot.writeFieldBegin('is_local_target', TType.BOOL, 5)
      oprot.writeBool(self.is_local_target)
      oprot.writeFieldEnd()
    if self.kudu_col_name is not None:
      oprot.writeFieldBegin('kudu_col_name', TType.STRING, 6)
      oprot.writeString(self.kudu_col_name)
      oprot.writeFieldEnd()
    if self.kudu_col_type is not None:
      oprot.writeFieldBegin('kudu_col_type', TType.STRUCT, 7)
      self.kudu_col_type.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.target_expr is None:
      raise TProtocol.TProtocolException(message='Required field target_expr is unset!')
    if self.is_bound_by_partition_columns is None:
      raise TProtocol.TProtocolException(message='Required field is_bound_by_partition_columns is unset!')
    if self.target_expr_slotids is None:
      raise TProtocol.TProtocolException(message='Required field target_expr_slotids is unset!')
    if self.is_local_target is None:
      raise TProtocol.TProtocolException(message='Required field is_local_target is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TRuntimeFilterDesc:
  """
  Attributes:
   - filter_id
   - src_expr
   - targets
   - planid_to_target_ndx
   - is_broadcast_join
   - has_local_targets
   - has_remote_targets
   - applied_on_partition_columns
   - ndv_estimate
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'filter_id', None, None, ), # 1
    (2, TType.STRUCT, 'src_expr', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 2
    (3, TType.LIST, 'targets', (TType.STRUCT,(TRuntimeFilterTargetDesc, TRuntimeFilterTargetDesc.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'planid_to_target_ndx', (TType.I32,None,TType.I32,None), None, ), # 4
    (5, TType.BOOL, 'is_broadcast_join', None, None, ), # 5
    (6, TType.BOOL, 'has_local_targets', None, None, ), # 6
    (7, TType.BOOL, 'has_remote_targets', None, None, ), # 7
    (8, TType.BOOL, 'applied_on_partition_columns', None, None, ), # 8
    (9, TType.I64, 'ndv_estimate', None, None, ), # 9
    (10, TType.I32, 'type', None, None, ), # 10
  )

  def __init__(self, filter_id=None, src_expr=None, targets=None, planid_to_target_ndx=None, is_broadcast_join=None, has_local_targets=None, has_remote_targets=None, applied_on_partition_columns=None, ndv_estimate=None, type=None,):
    self.filter_id = filter_id
    self.src_expr = src_expr
    self.targets = targets
    self.planid_to_target_ndx = planid_to_target_ndx
    self.is_broadcast_join = is_broadcast_join
    self.has_local_targets = has_local_targets
    self.has_remote_targets = has_remote_targets
    self.applied_on_partition_columns = applied_on_partition_columns
    self.ndv_estimate = ndv_estimate
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.filter_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.src_expr = Exprs.ttypes.TExpr()
          self.src_expr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.targets = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = TRuntimeFilterTargetDesc()
            _elem12.read(iprot)
            self.targets.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.planid_to_target_ndx = {}
          (_ktype14, _vtype15, _size13 ) = iprot.readMapBegin() 
          for _i17 in xrange(_size13):
            _key18 = iprot.readI32();
            _val19 = iprot.readI32();
            self.planid_to_target_ndx[_key18] = _val19
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.is_broadcast_join = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.has_local_targets = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.has_remote_targets = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.applied_on_partition_columns = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.ndv_estimate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TRuntimeFilterDesc')
    if self.filter_id is not None:
      oprot.writeFieldBegin('filter_id', TType.I32, 1)
      oprot.writeI32(self.filter_id)
      oprot.writeFieldEnd()
    if self.src_expr is not None:
      oprot.writeFieldBegin('src_expr', TType.STRUCT, 2)
      self.src_expr.write(oprot)
      oprot.writeFieldEnd()
    if self.targets is not None:
      oprot.writeFieldBegin('targets', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.targets))
      for iter20 in self.targets:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.planid_to_target_ndx is not None:
      oprot.writeFieldBegin('planid_to_target_ndx', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.planid_to_target_ndx))
      for kiter21,viter22 in self.planid_to_target_ndx.items():
        oprot.writeI32(kiter21)
        oprot.writeI32(viter22)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.is_broadcast_join is not None:
      oprot.writeFieldBegin('is_broadcast_join', TType.BOOL, 5)
      oprot.writeBool(self.is_broadcast_join)
      oprot.writeFieldEnd()
    if self.has_local_targets is not None:
      oprot.writeFieldBegin('has_local_targets', TType.BOOL, 6)
      oprot.writeBool(self.has_local_targets)
      oprot.writeFieldEnd()
    if self.has_remote_targets is not None:
      oprot.writeFieldBegin('has_remote_targets', TType.BOOL, 7)
      oprot.writeBool(self.has_remote_targets)
      oprot.writeFieldEnd()
    if self.applied_on_partition_columns is not None:
      oprot.writeFieldBegin('applied_on_partition_columns', TType.BOOL, 8)
      oprot.writeBool(self.applied_on_partition_columns)
      oprot.writeFieldEnd()
    if self.ndv_estimate is not None:
      oprot.writeFieldBegin('ndv_estimate', TType.I64, 9)
      oprot.writeI64(self.ndv_estimate)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 10)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.filter_id is None:
      raise TProtocol.TProtocolException(message='Required field filter_id is unset!')
    if self.src_expr is None:
      raise TProtocol.TProtocolException(message='Required field src_expr is unset!')
    if self.targets is None:
      raise TProtocol.TProtocolException(message='Required field targets is unset!')
    if self.planid_to_target_ndx is None:
      raise TProtocol.TProtocolException(message='Required field planid_to_target_ndx is unset!')
    if self.is_broadcast_join is None:
      raise TProtocol.TProtocolException(message='Required field is_broadcast_join is unset!')
    if self.has_local_targets is None:
      raise TProtocol.TProtocolException(message='Required field has_local_targets is unset!')
    if self.has_remote_targets is None:
      raise TProtocol.TProtocolException(message='Required field has_remote_targets is unset!')
    if self.applied_on_partition_columns is None:
      raise TProtocol.TProtocolException(message='Required field applied_on_partition_columns is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsFileSplit:
  """
  Attributes:
   - file_name
   - offset
   - length
   - partition_id
   - file_length
   - file_compression
   - mtime
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'file_name', None, None, ), # 1
    (2, TType.I64, 'offset', None, None, ), # 2
    (3, TType.I64, 'length', None, None, ), # 3
    (4, TType.I64, 'partition_id', None, None, ), # 4
    (5, TType.I64, 'file_length', None, None, ), # 5
    (6, TType.I32, 'file_compression', None, None, ), # 6
    (7, TType.I64, 'mtime', None, None, ), # 7
  )

  def __init__(self, file_name=None, offset=None, length=None, partition_id=None, file_length=None, file_compression=None, mtime=None,):
    self.file_name = file_name
    self.offset = offset
    self.length = length
    self.partition_id = partition_id
    self.file_length = file_length
    self.file_compression = file_compression
    self.mtime = mtime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.file_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.offset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.partition_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.file_length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.file_compression = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.mtime = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsFileSplit')
    if self.file_name is not None:
      oprot.writeFieldBegin('file_name', TType.STRING, 1)
      oprot.writeString(self.file_name)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I64, 2)
      oprot.writeI64(self.offset)
      oprot.writeFieldEnd()
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I64, 3)
      oprot.writeI64(self.length)
      oprot.writeFieldEnd()
    if self.partition_id is not None:
      oprot.writeFieldBegin('partition_id', TType.I64, 4)
      oprot.writeI64(self.partition_id)
      oprot.writeFieldEnd()
    if self.file_length is not None:
      oprot.writeFieldBegin('file_length', TType.I64, 5)
      oprot.writeI64(self.file_length)
      oprot.writeFieldEnd()
    if self.file_compression is not None:
      oprot.writeFieldBegin('file_compression', TType.I32, 6)
      oprot.writeI32(self.file_compression)
      oprot.writeFieldEnd()
    if self.mtime is not None:
      oprot.writeFieldBegin('mtime', TType.I64, 7)
      oprot.writeI64(self.mtime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.file_name is None:
      raise TProtocol.TProtocolException(message='Required field file_name is unset!')
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.length is None:
      raise TProtocol.TProtocolException(message='Required field length is unset!')
    if self.partition_id is None:
      raise TProtocol.TProtocolException(message='Required field partition_id is unset!')
    if self.file_length is None:
      raise TProtocol.TProtocolException(message='Required field file_length is unset!')
    if self.file_compression is None:
      raise TProtocol.TProtocolException(message='Required field file_compression is unset!')
    if self.mtime is None:
      raise TProtocol.TProtocolException(message='Required field mtime is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THBaseKeyRange:
  """
  Attributes:
   - startKey
   - stopKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'startKey', None, None, ), # 1
    (2, TType.STRING, 'stopKey', None, None, ), # 2
  )

  def __init__(self, startKey=None, stopKey=None,):
    self.startKey = startKey
    self.stopKey = stopKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.startKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stopKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THBaseKeyRange')
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.STRING, 1)
      oprot.writeString(self.startKey)
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.STRING, 2)
      oprot.writeString(self.stopKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TScanRange:
  """
  Attributes:
   - hdfs_file_split
   - hbase_key_range
   - kudu_scan_token
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hdfs_file_split', (THdfsFileSplit, THdfsFileSplit.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'hbase_key_range', (THBaseKeyRange, THBaseKeyRange.thrift_spec), None, ), # 2
    (3, TType.STRING, 'kudu_scan_token', None, None, ), # 3
  )

  def __init__(self, hdfs_file_split=None, hbase_key_range=None, kudu_scan_token=None,):
    self.hdfs_file_split = hdfs_file_split
    self.hbase_key_range = hbase_key_range
    self.kudu_scan_token = kudu_scan_token

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hdfs_file_split = THdfsFileSplit()
          self.hdfs_file_split.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.hbase_key_range = THBaseKeyRange()
          self.hbase_key_range.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.kudu_scan_token = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TScanRange')
    if self.hdfs_file_split is not None:
      oprot.writeFieldBegin('hdfs_file_split', TType.STRUCT, 1)
      self.hdfs_file_split.write(oprot)
      oprot.writeFieldEnd()
    if self.hbase_key_range is not None:
      oprot.writeFieldBegin('hbase_key_range', TType.STRUCT, 2)
      self.hbase_key_range.write(oprot)
      oprot.writeFieldEnd()
    if self.kudu_scan_token is not None:
      oprot.writeFieldBegin('kudu_scan_token', TType.STRING, 3)
      oprot.writeString(self.kudu_scan_token)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsScanNode:
  """
  Attributes:
   - tuple_id
   - collection_conjuncts
   - replica_preference
   - random_replica
   - skip_header_line_count
   - use_mt_scan_node
   - min_max_conjuncts
   - min_max_tuple_id
   - dictionary_filter_conjuncts
   - parquet_count_star_slot_offset
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tuple_id', None, None, ), # 1
    (2, TType.MAP, 'collection_conjuncts', (TType.I32,None,TType.LIST,(TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec))), None, ), # 2
    (3, TType.I32, 'replica_preference', None, None, ), # 3
    (4, TType.BOOL, 'random_replica', None, None, ), # 4
    (5, TType.I32, 'skip_header_line_count', None, None, ), # 5
    (6, TType.BOOL, 'use_mt_scan_node', None, None, ), # 6
    (7, TType.LIST, 'min_max_conjuncts', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 7
    (8, TType.I32, 'min_max_tuple_id', None, None, ), # 8
    (9, TType.MAP, 'dictionary_filter_conjuncts', (TType.I32,None,TType.LIST,(TType.I32,None)), None, ), # 9
    (10, TType.I32, 'parquet_count_star_slot_offset', None, None, ), # 10
  )

  def __init__(self, tuple_id=None, collection_conjuncts=None, replica_preference=None, random_replica=None, skip_header_line_count=None, use_mt_scan_node=None, min_max_conjuncts=None, min_max_tuple_id=None, dictionary_filter_conjuncts=None, parquet_count_star_slot_offset=None,):
    self.tuple_id = tuple_id
    self.collection_conjuncts = collection_conjuncts
    self.replica_preference = replica_preference
    self.random_replica = random_replica
    self.skip_header_line_count = skip_header_line_count
    self.use_mt_scan_node = use_mt_scan_node
    self.min_max_conjuncts = min_max_conjuncts
    self.min_max_tuple_id = min_max_tuple_id
    self.dictionary_filter_conjuncts = dictionary_filter_conjuncts
    self.parquet_count_star_slot_offset = parquet_count_star_slot_offset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.collection_conjuncts = {}
          (_ktype24, _vtype25, _size23 ) = iprot.readMapBegin() 
          for _i27 in xrange(_size23):
            _key28 = iprot.readI32();
            _val29 = []
            (_etype33, _size30) = iprot.readListBegin()
            for _i34 in xrange(_size30):
              _elem35 = Exprs.ttypes.TExpr()
              _elem35.read(iprot)
              _val29.append(_elem35)
            iprot.readListEnd()
            self.collection_conjuncts[_key28] = _val29
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.replica_preference = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.random_replica = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.skip_header_line_count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.use_mt_scan_node = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.min_max_conjuncts = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = Exprs.ttypes.TExpr()
            _elem41.read(iprot)
            self.min_max_conjuncts.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.min_max_tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.dictionary_filter_conjuncts = {}
          (_ktype43, _vtype44, _size42 ) = iprot.readMapBegin() 
          for _i46 in xrange(_size42):
            _key47 = iprot.readI32();
            _val48 = []
            (_etype52, _size49) = iprot.readListBegin()
            for _i53 in xrange(_size49):
              _elem54 = iprot.readI32();
              _val48.append(_elem54)
            iprot.readListEnd()
            self.dictionary_filter_conjuncts[_key47] = _val48
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.parquet_count_star_slot_offset = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsScanNode')
    if self.tuple_id is not None:
      oprot.writeFieldBegin('tuple_id', TType.I32, 1)
      oprot.writeI32(self.tuple_id)
      oprot.writeFieldEnd()
    if self.collection_conjuncts is not None:
      oprot.writeFieldBegin('collection_conjuncts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.collection_conjuncts))
      for kiter55,viter56 in self.collection_conjuncts.items():
        oprot.writeI32(kiter55)
        oprot.writeListBegin(TType.STRUCT, len(viter56))
        for iter57 in viter56:
          iter57.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.replica_preference is not None:
      oprot.writeFieldBegin('replica_preference', TType.I32, 3)
      oprot.writeI32(self.replica_preference)
      oprot.writeFieldEnd()
    if self.random_replica is not None:
      oprot.writeFieldBegin('random_replica', TType.BOOL, 4)
      oprot.writeBool(self.random_replica)
      oprot.writeFieldEnd()
    if self.skip_header_line_count is not None:
      oprot.writeFieldBegin('skip_header_line_count', TType.I32, 5)
      oprot.writeI32(self.skip_header_line_count)
      oprot.writeFieldEnd()
    if self.use_mt_scan_node is not None:
      oprot.writeFieldBegin('use_mt_scan_node', TType.BOOL, 6)
      oprot.writeBool(self.use_mt_scan_node)
      oprot.writeFieldEnd()
    if self.min_max_conjuncts is not None:
      oprot.writeFieldBegin('min_max_conjuncts', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.min_max_conjuncts))
      for iter58 in self.min_max_conjuncts:
        iter58.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.min_max_tuple_id is not None:
      oprot.writeFieldBegin('min_max_tuple_id', TType.I32, 8)
      oprot.writeI32(self.min_max_tuple_id)
      oprot.writeFieldEnd()
    if self.dictionary_filter_conjuncts is not None:
      oprot.writeFieldBegin('dictionary_filter_conjuncts', TType.MAP, 9)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.dictionary_filter_conjuncts))
      for kiter59,viter60 in self.dictionary_filter_conjuncts.items():
        oprot.writeI32(kiter59)
        oprot.writeListBegin(TType.I32, len(viter60))
        for iter61 in viter60:
          oprot.writeI32(iter61)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.parquet_count_star_slot_offset is not None:
      oprot.writeFieldBegin('parquet_count_star_slot_offset', TType.I32, 10)
      oprot.writeI32(self.parquet_count_star_slot_offset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field tuple_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDataSourceScanNode:
  """
  Attributes:
   - tuple_id
   - data_source
   - init_string
   - accepted_predicates
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tuple_id', None, None, ), # 1
    (2, TType.STRUCT, 'data_source', (CatalogObjects.ttypes.TDataSource, CatalogObjects.ttypes.TDataSource.thrift_spec), None, ), # 2
    (3, TType.STRING, 'init_string', None, None, ), # 3
    (4, TType.LIST, 'accepted_predicates', (TType.LIST,(TType.STRUCT,(ExternalDataSource.ttypes.TBinaryPredicate, ExternalDataSource.ttypes.TBinaryPredicate.thrift_spec))), None, ), # 4
  )

  def __init__(self, tuple_id=None, data_source=None, init_string=None, accepted_predicates=None,):
    self.tuple_id = tuple_id
    self.data_source = data_source
    self.init_string = init_string
    self.accepted_predicates = accepted_predicates

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data_source = CatalogObjects.ttypes.TDataSource()
          self.data_source.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.init_string = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.accepted_predicates = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = []
            (_etype71, _size68) = iprot.readListBegin()
            for _i72 in xrange(_size68):
              _elem73 = ExternalDataSource.ttypes.TBinaryPredicate()
              _elem73.read(iprot)
              _elem67.append(_elem73)
            iprot.readListEnd()
            self.accepted_predicates.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDataSourceScanNode')
    if self.tuple_id is not None:
      oprot.writeFieldBegin('tuple_id', TType.I32, 1)
      oprot.writeI32(self.tuple_id)
      oprot.writeFieldEnd()
    if self.data_source is not None:
      oprot.writeFieldBegin('data_source', TType.STRUCT, 2)
      self.data_source.write(oprot)
      oprot.writeFieldEnd()
    if self.init_string is not None:
      oprot.writeFieldBegin('init_string', TType.STRING, 3)
      oprot.writeString(self.init_string)
      oprot.writeFieldEnd()
    if self.accepted_predicates is not None:
      oprot.writeFieldBegin('accepted_predicates', TType.LIST, 4)
      oprot.writeListBegin(TType.LIST, len(self.accepted_predicates))
      for iter74 in self.accepted_predicates:
        oprot.writeListBegin(TType.STRUCT, len(iter74))
        for iter75 in iter74:
          iter75.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field tuple_id is unset!')
    if self.data_source is None:
      raise TProtocol.TProtocolException(message='Required field data_source is unset!')
    if self.init_string is None:
      raise TProtocol.TProtocolException(message='Required field init_string is unset!')
    if self.accepted_predicates is None:
      raise TProtocol.TProtocolException(message='Required field accepted_predicates is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THBaseFilter:
  """
  Attributes:
   - family
   - qualifier
   - op_ordinal
   - filter_constant
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'family', None, None, ), # 1
    (2, TType.STRING, 'qualifier', None, None, ), # 2
    (3, TType.I32, 'op_ordinal', None, None, ), # 3
    (4, TType.STRING, 'filter_constant', None, None, ), # 4
  )

  def __init__(self, family=None, qualifier=None, op_ordinal=None, filter_constant=None,):
    self.family = family
    self.qualifier = qualifier
    self.op_ordinal = op_ordinal
    self.filter_constant = filter_constant

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.family = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.qualifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.op_ordinal = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.filter_constant = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THBaseFilter')
    if self.family is not None:
      oprot.writeFieldBegin('family', TType.STRING, 1)
      oprot.writeString(self.family)
      oprot.writeFieldEnd()
    if self.qualifier is not None:
      oprot.writeFieldBegin('qualifier', TType.STRING, 2)
      oprot.writeString(self.qualifier)
      oprot.writeFieldEnd()
    if self.op_ordinal is not None:
      oprot.writeFieldBegin('op_ordinal', TType.I32, 3)
      oprot.writeI32(self.op_ordinal)
      oprot.writeFieldEnd()
    if self.filter_constant is not None:
      oprot.writeFieldBegin('filter_constant', TType.STRING, 4)
      oprot.writeString(self.filter_constant)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.family is None:
      raise TProtocol.TProtocolException(message='Required field family is unset!')
    if self.qualifier is None:
      raise TProtocol.TProtocolException(message='Required field qualifier is unset!')
    if self.op_ordinal is None:
      raise TProtocol.TProtocolException(message='Required field op_ordinal is unset!')
    if self.filter_constant is None:
      raise TProtocol.TProtocolException(message='Required field filter_constant is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THBaseScanNode:
  """
  Attributes:
   - tuple_id
   - table_name
   - filters
   - suggested_max_caching
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tuple_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.LIST, 'filters', (TType.STRUCT,(THBaseFilter, THBaseFilter.thrift_spec)), None, ), # 3
    (4, TType.I32, 'suggested_max_caching', None, None, ), # 4
  )

  def __init__(self, tuple_id=None, table_name=None, filters=None, suggested_max_caching=None,):
    self.tuple_id = tuple_id
    self.table_name = table_name
    self.filters = filters
    self.suggested_max_caching = suggested_max_caching

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.filters = []
          (_etype79, _size76) = iprot.readListBegin()
          for _i80 in xrange(_size76):
            _elem81 = THBaseFilter()
            _elem81.read(iprot)
            self.filters.append(_elem81)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.suggested_max_caching = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THBaseScanNode')
    if self.tuple_id is not None:
      oprot.writeFieldBegin('tuple_id', TType.I32, 1)
      oprot.writeI32(self.tuple_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.filters is not None:
      oprot.writeFieldBegin('filters', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.filters))
      for iter82 in self.filters:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.suggested_max_caching is not None:
      oprot.writeFieldBegin('suggested_max_caching', TType.I32, 4)
      oprot.writeI32(self.suggested_max_caching)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field tuple_id is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TKuduScanNode:
  """
  Attributes:
   - tuple_id
   - use_mt_scan_node
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tuple_id', None, None, ), # 1
    (2, TType.BOOL, 'use_mt_scan_node', None, None, ), # 2
  )

  def __init__(self, tuple_id=None, use_mt_scan_node=None,):
    self.tuple_id = tuple_id
    self.use_mt_scan_node = use_mt_scan_node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.use_mt_scan_node = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TKuduScanNode')
    if self.tuple_id is not None:
      oprot.writeFieldBegin('tuple_id', TType.I32, 1)
      oprot.writeI32(self.tuple_id)
      oprot.writeFieldEnd()
    if self.use_mt_scan_node is not None:
      oprot.writeFieldBegin('use_mt_scan_node', TType.BOOL, 2)
      oprot.writeBool(self.use_mt_scan_node)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field tuple_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TEqJoinCondition:
  """
  Attributes:
   - left
   - right
   - is_not_distinct_from
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'left', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'right', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'is_not_distinct_from', None, None, ), # 3
  )

  def __init__(self, left=None, right=None, is_not_distinct_from=None,):
    self.left = left
    self.right = right
    self.is_not_distinct_from = is_not_distinct_from

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.left = Exprs.ttypes.TExpr()
          self.left.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.right = Exprs.ttypes.TExpr()
          self.right.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_not_distinct_from = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TEqJoinCondition')
    if self.left is not None:
      oprot.writeFieldBegin('left', TType.STRUCT, 1)
      self.left.write(oprot)
      oprot.writeFieldEnd()
    if self.right is not None:
      oprot.writeFieldBegin('right', TType.STRUCT, 2)
      self.right.write(oprot)
      oprot.writeFieldEnd()
    if self.is_not_distinct_from is not None:
      oprot.writeFieldBegin('is_not_distinct_from', TType.BOOL, 3)
      oprot.writeBool(self.is_not_distinct_from)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.left is None:
      raise TProtocol.TProtocolException(message='Required field left is unset!')
    if self.right is None:
      raise TProtocol.TProtocolException(message='Required field right is unset!')
    if self.is_not_distinct_from is None:
      raise TProtocol.TProtocolException(message='Required field is_not_distinct_from is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THashJoinNode:
  """
  Attributes:
   - join_op
   - eq_join_conjuncts
   - other_join_conjuncts
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'join_op', None, None, ), # 1
    (2, TType.LIST, 'eq_join_conjuncts', (TType.STRUCT,(TEqJoinCondition, TEqJoinCondition.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'other_join_conjuncts', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 3
  )

  def __init__(self, join_op=None, eq_join_conjuncts=None, other_join_conjuncts=None,):
    self.join_op = join_op
    self.eq_join_conjuncts = eq_join_conjuncts
    self.other_join_conjuncts = other_join_conjuncts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.join_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.eq_join_conjuncts = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = TEqJoinCondition()
            _elem88.read(iprot)
            self.eq_join_conjuncts.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.other_join_conjuncts = []
          (_etype92, _size89) = iprot.readListBegin()
          for _i93 in xrange(_size89):
            _elem94 = Exprs.ttypes.TExpr()
            _elem94.read(iprot)
            self.other_join_conjuncts.append(_elem94)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THashJoinNode')
    if self.join_op is not None:
      oprot.writeFieldBegin('join_op', TType.I32, 1)
      oprot.writeI32(self.join_op)
      oprot.writeFieldEnd()
    if self.eq_join_conjuncts is not None:
      oprot.writeFieldBegin('eq_join_conjuncts', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.eq_join_conjuncts))
      for iter95 in self.eq_join_conjuncts:
        iter95.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.other_join_conjuncts is not None:
      oprot.writeFieldBegin('other_join_conjuncts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.other_join_conjuncts))
      for iter96 in self.other_join_conjuncts:
        iter96.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.join_op is None:
      raise TProtocol.TProtocolException(message='Required field join_op is unset!')
    if self.eq_join_conjuncts is None:
      raise TProtocol.TProtocolException(message='Required field eq_join_conjuncts is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TNestedLoopJoinNode:
  """
  Attributes:
   - join_op
   - join_conjuncts
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'join_op', None, None, ), # 1
    (2, TType.LIST, 'join_conjuncts', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 2
  )

  def __init__(self, join_op=None, join_conjuncts=None,):
    self.join_op = join_op
    self.join_conjuncts = join_conjuncts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.join_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.join_conjuncts = []
          (_etype100, _size97) = iprot.readListBegin()
          for _i101 in xrange(_size97):
            _elem102 = Exprs.ttypes.TExpr()
            _elem102.read(iprot)
            self.join_conjuncts.append(_elem102)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TNestedLoopJoinNode')
    if self.join_op is not None:
      oprot.writeFieldBegin('join_op', TType.I32, 1)
      oprot.writeI32(self.join_op)
      oprot.writeFieldEnd()
    if self.join_conjuncts is not None:
      oprot.writeFieldBegin('join_conjuncts', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.join_conjuncts))
      for iter103 in self.join_conjuncts:
        iter103.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.join_op is None:
      raise TProtocol.TProtocolException(message='Required field join_op is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAggregationNode:
  """
  Attributes:
   - grouping_exprs
   - aggregate_functions
   - intermediate_tuple_id
   - output_tuple_id
   - need_finalize
   - use_streaming_preaggregation
   - estimated_input_cardinality
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'grouping_exprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'aggregate_functions', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 2
    (3, TType.I32, 'intermediate_tuple_id', None, None, ), # 3
    (4, TType.I32, 'output_tuple_id', None, None, ), # 4
    (5, TType.BOOL, 'need_finalize', None, None, ), # 5
    (6, TType.BOOL, 'use_streaming_preaggregation', None, None, ), # 6
    (7, TType.I64, 'estimated_input_cardinality', None, None, ), # 7
  )

  def __init__(self, grouping_exprs=None, aggregate_functions=None, intermediate_tuple_id=None, output_tuple_id=None, need_finalize=None, use_streaming_preaggregation=None, estimated_input_cardinality=None,):
    self.grouping_exprs = grouping_exprs
    self.aggregate_functions = aggregate_functions
    self.intermediate_tuple_id = intermediate_tuple_id
    self.output_tuple_id = output_tuple_id
    self.need_finalize = need_finalize
    self.use_streaming_preaggregation = use_streaming_preaggregation
    self.estimated_input_cardinality = estimated_input_cardinality

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.grouping_exprs = []
          (_etype107, _size104) = iprot.readListBegin()
          for _i108 in xrange(_size104):
            _elem109 = Exprs.ttypes.TExpr()
            _elem109.read(iprot)
            self.grouping_exprs.append(_elem109)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.aggregate_functions = []
          (_etype113, _size110) = iprot.readListBegin()
          for _i114 in xrange(_size110):
            _elem115 = Exprs.ttypes.TExpr()
            _elem115.read(iprot)
            self.aggregate_functions.append(_elem115)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.intermediate_tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.output_tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.need_finalize = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.use_streaming_preaggregation = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.estimated_input_cardinality = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAggregationNode')
    if self.grouping_exprs is not None:
      oprot.writeFieldBegin('grouping_exprs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.grouping_exprs))
      for iter116 in self.grouping_exprs:
        iter116.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aggregate_functions is not None:
      oprot.writeFieldBegin('aggregate_functions', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.aggregate_functions))
      for iter117 in self.aggregate_functions:
        iter117.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.intermediate_tuple_id is not None:
      oprot.writeFieldBegin('intermediate_tuple_id', TType.I32, 3)
      oprot.writeI32(self.intermediate_tuple_id)
      oprot.writeFieldEnd()
    if self.output_tuple_id is not None:
      oprot.writeFieldBegin('output_tuple_id', TType.I32, 4)
      oprot.writeI32(self.output_tuple_id)
      oprot.writeFieldEnd()
    if self.need_finalize is not None:
      oprot.writeFieldBegin('need_finalize', TType.BOOL, 5)
      oprot.writeBool(self.need_finalize)
      oprot.writeFieldEnd()
    if self.use_streaming_preaggregation is not None:
      oprot.writeFieldBegin('use_streaming_preaggregation', TType.BOOL, 6)
      oprot.writeBool(self.use_streaming_preaggregation)
      oprot.writeFieldEnd()
    if self.estimated_input_cardinality is not None:
      oprot.writeFieldBegin('estimated_input_cardinality', TType.I64, 7)
      oprot.writeI64(self.estimated_input_cardinality)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.aggregate_functions is None:
      raise TProtocol.TProtocolException(message='Required field aggregate_functions is unset!')
    if self.intermediate_tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field intermediate_tuple_id is unset!')
    if self.output_tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field output_tuple_id is unset!')
    if self.need_finalize is None:
      raise TProtocol.TProtocolException(message='Required field need_finalize is unset!')
    if self.use_streaming_preaggregation is None:
      raise TProtocol.TProtocolException(message='Required field use_streaming_preaggregation is unset!')
    if self.estimated_input_cardinality is None:
      raise TProtocol.TProtocolException(message='Required field estimated_input_cardinality is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSortInfo:
  """
  Attributes:
   - ordering_exprs
   - is_asc_order
   - nulls_first
   - sort_tuple_slot_exprs
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'ordering_exprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'is_asc_order', (TType.BOOL,None), None, ), # 2
    (3, TType.LIST, 'nulls_first', (TType.BOOL,None), None, ), # 3
    (4, TType.LIST, 'sort_tuple_slot_exprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 4
  )

  def __init__(self, ordering_exprs=None, is_asc_order=None, nulls_first=None, sort_tuple_slot_exprs=None,):
    self.ordering_exprs = ordering_exprs
    self.is_asc_order = is_asc_order
    self.nulls_first = nulls_first
    self.sort_tuple_slot_exprs = sort_tuple_slot_exprs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.ordering_exprs = []
          (_etype121, _size118) = iprot.readListBegin()
          for _i122 in xrange(_size118):
            _elem123 = Exprs.ttypes.TExpr()
            _elem123.read(iprot)
            self.ordering_exprs.append(_elem123)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.is_asc_order = []
          (_etype127, _size124) = iprot.readListBegin()
          for _i128 in xrange(_size124):
            _elem129 = iprot.readBool();
            self.is_asc_order.append(_elem129)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.nulls_first = []
          (_etype133, _size130) = iprot.readListBegin()
          for _i134 in xrange(_size130):
            _elem135 = iprot.readBool();
            self.nulls_first.append(_elem135)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.sort_tuple_slot_exprs = []
          (_etype139, _size136) = iprot.readListBegin()
          for _i140 in xrange(_size136):
            _elem141 = Exprs.ttypes.TExpr()
            _elem141.read(iprot)
            self.sort_tuple_slot_exprs.append(_elem141)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSortInfo')
    if self.ordering_exprs is not None:
      oprot.writeFieldBegin('ordering_exprs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.ordering_exprs))
      for iter142 in self.ordering_exprs:
        iter142.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.is_asc_order is not None:
      oprot.writeFieldBegin('is_asc_order', TType.LIST, 2)
      oprot.writeListBegin(TType.BOOL, len(self.is_asc_order))
      for iter143 in self.is_asc_order:
        oprot.writeBool(iter143)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nulls_first is not None:
      oprot.writeFieldBegin('nulls_first', TType.LIST, 3)
      oprot.writeListBegin(TType.BOOL, len(self.nulls_first))
      for iter144 in self.nulls_first:
        oprot.writeBool(iter144)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sort_tuple_slot_exprs is not None:
      oprot.writeFieldBegin('sort_tuple_slot_exprs', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.sort_tuple_slot_exprs))
      for iter145 in self.sort_tuple_slot_exprs:
        iter145.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ordering_exprs is None:
      raise TProtocol.TProtocolException(message='Required field ordering_exprs is unset!')
    if self.is_asc_order is None:
      raise TProtocol.TProtocolException(message='Required field is_asc_order is unset!')
    if self.nulls_first is None:
      raise TProtocol.TProtocolException(message='Required field nulls_first is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSortNode:
  """
  Attributes:
   - sort_info
   - type
   - offset
   - isAnalyticSort
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sort_info', (TSortInfo, TSortInfo.thrift_spec), None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
    (3, TType.I64, 'offset', None, None, ), # 3
    (4, TType.BOOL, 'isAnalyticSort', None, None, ), # 4
  )

  def __init__(self, sort_info=None, type=None, offset=None, isAnalyticSort=None,):
    self.sort_info = sort_info
    self.type = type
    self.offset = offset
    self.isAnalyticSort = isAnalyticSort

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sort_info = TSortInfo()
          self.sort_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.offset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isAnalyticSort = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSortNode')
    if self.sort_info is not None:
      oprot.writeFieldBegin('sort_info', TType.STRUCT, 1)
      self.sort_info.write(oprot)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I64, 3)
      oprot.writeI64(self.offset)
      oprot.writeFieldEnd()
    if self.isAnalyticSort is not None:
      oprot.writeFieldBegin('isAnalyticSort', TType.BOOL, 4)
      oprot.writeBool(self.isAnalyticSort)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sort_info is None:
      raise TProtocol.TProtocolException(message='Required field sort_info is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAnalyticWindowBoundary:
  """
  Attributes:
   - type
   - range_offset_predicate
   - rows_offset_value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'range_offset_predicate', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 2
    (3, TType.I64, 'rows_offset_value', None, None, ), # 3
  )

  def __init__(self, type=None, range_offset_predicate=None, rows_offset_value=None,):
    self.type = type
    self.range_offset_predicate = range_offset_predicate
    self.rows_offset_value = rows_offset_value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.range_offset_predicate = Exprs.ttypes.TExpr()
          self.range_offset_predicate.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.rows_offset_value = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAnalyticWindowBoundary')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.range_offset_predicate is not None:
      oprot.writeFieldBegin('range_offset_predicate', TType.STRUCT, 2)
      self.range_offset_predicate.write(oprot)
      oprot.writeFieldEnd()
    if self.rows_offset_value is not None:
      oprot.writeFieldBegin('rows_offset_value', TType.I64, 3)
      oprot.writeI64(self.rows_offset_value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAnalyticWindow:
  """
  Attributes:
   - type
   - window_start
   - window_end
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'window_start', (TAnalyticWindowBoundary, TAnalyticWindowBoundary.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'window_end', (TAnalyticWindowBoundary, TAnalyticWindowBoundary.thrift_spec), None, ), # 3
  )

  def __init__(self, type=None, window_start=None, window_end=None,):
    self.type = type
    self.window_start = window_start
    self.window_end = window_end

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.window_start = TAnalyticWindowBoundary()
          self.window_start.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.window_end = TAnalyticWindowBoundary()
          self.window_end.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAnalyticWindow')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.window_start is not None:
      oprot.writeFieldBegin('window_start', TType.STRUCT, 2)
      self.window_start.write(oprot)
      oprot.writeFieldEnd()
    if self.window_end is not None:
      oprot.writeFieldBegin('window_end', TType.STRUCT, 3)
      self.window_end.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAnalyticNode:
  """
  Attributes:
   - partition_exprs
   - order_by_exprs
   - analytic_functions
   - window
   - intermediate_tuple_id
   - output_tuple_id
   - buffered_tuple_id
   - partition_by_eq
   - order_by_eq
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partition_exprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'order_by_exprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'analytic_functions', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'window', (TAnalyticWindow, TAnalyticWindow.thrift_spec), None, ), # 4
    (5, TType.I32, 'intermediate_tuple_id', None, None, ), # 5
    (6, TType.I32, 'output_tuple_id', None, None, ), # 6
    (7, TType.I32, 'buffered_tuple_id', None, None, ), # 7
    (8, TType.STRUCT, 'partition_by_eq', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'order_by_eq', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 9
  )

  def __init__(self, partition_exprs=None, order_by_exprs=None, analytic_functions=None, window=None, intermediate_tuple_id=None, output_tuple_id=None, buffered_tuple_id=None, partition_by_eq=None, order_by_eq=None,):
    self.partition_exprs = partition_exprs
    self.order_by_exprs = order_by_exprs
    self.analytic_functions = analytic_functions
    self.window = window
    self.intermediate_tuple_id = intermediate_tuple_id
    self.output_tuple_id = output_tuple_id
    self.buffered_tuple_id = buffered_tuple_id
    self.partition_by_eq = partition_by_eq
    self.order_by_eq = order_by_eq

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partition_exprs = []
          (_etype149, _size146) = iprot.readListBegin()
          for _i150 in xrange(_size146):
            _elem151 = Exprs.ttypes.TExpr()
            _elem151.read(iprot)
            self.partition_exprs.append(_elem151)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.order_by_exprs = []
          (_etype155, _size152) = iprot.readListBegin()
          for _i156 in xrange(_size152):
            _elem157 = Exprs.ttypes.TExpr()
            _elem157.read(iprot)
            self.order_by_exprs.append(_elem157)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.analytic_functions = []
          (_etype161, _size158) = iprot.readListBegin()
          for _i162 in xrange(_size158):
            _elem163 = Exprs.ttypes.TExpr()
            _elem163.read(iprot)
            self.analytic_functions.append(_elem163)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.window = TAnalyticWindow()
          self.window.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.intermediate_tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.output_tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.buffered_tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.partition_by_eq = Exprs.ttypes.TExpr()
          self.partition_by_eq.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.order_by_eq = Exprs.ttypes.TExpr()
          self.order_by_eq.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAnalyticNode')
    if self.partition_exprs is not None:
      oprot.writeFieldBegin('partition_exprs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_exprs))
      for iter164 in self.partition_exprs:
        iter164.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.order_by_exprs is not None:
      oprot.writeFieldBegin('order_by_exprs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.order_by_exprs))
      for iter165 in self.order_by_exprs:
        iter165.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.analytic_functions is not None:
      oprot.writeFieldBegin('analytic_functions', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.analytic_functions))
      for iter166 in self.analytic_functions:
        iter166.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.window is not None:
      oprot.writeFieldBegin('window', TType.STRUCT, 4)
      self.window.write(oprot)
      oprot.writeFieldEnd()
    if self.intermediate_tuple_id is not None:
      oprot.writeFieldBegin('intermediate_tuple_id', TType.I32, 5)
      oprot.writeI32(self.intermediate_tuple_id)
      oprot.writeFieldEnd()
    if self.output_tuple_id is not None:
      oprot.writeFieldBegin('output_tuple_id', TType.I32, 6)
      oprot.writeI32(self.output_tuple_id)
      oprot.writeFieldEnd()
    if self.buffered_tuple_id is not None:
      oprot.writeFieldBegin('buffered_tuple_id', TType.I32, 7)
      oprot.writeI32(self.buffered_tuple_id)
      oprot.writeFieldEnd()
    if self.partition_by_eq is not None:
      oprot.writeFieldBegin('partition_by_eq', TType.STRUCT, 8)
      self.partition_by_eq.write(oprot)
      oprot.writeFieldEnd()
    if self.order_by_eq is not None:
      oprot.writeFieldBegin('order_by_eq', TType.STRUCT, 9)
      self.order_by_eq.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partition_exprs is None:
      raise TProtocol.TProtocolException(message='Required field partition_exprs is unset!')
    if self.order_by_exprs is None:
      raise TProtocol.TProtocolException(message='Required field order_by_exprs is unset!')
    if self.analytic_functions is None:
      raise TProtocol.TProtocolException(message='Required field analytic_functions is unset!')
    if self.intermediate_tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field intermediate_tuple_id is unset!')
    if self.output_tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field output_tuple_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUnionNode:
  """
  Attributes:
   - tuple_id
   - result_expr_lists
   - const_expr_lists
   - first_materialized_child_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tuple_id', None, None, ), # 1
    (2, TType.LIST, 'result_expr_lists', (TType.LIST,(TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec))), None, ), # 2
    (3, TType.LIST, 'const_expr_lists', (TType.LIST,(TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec))), None, ), # 3
    (4, TType.I64, 'first_materialized_child_idx', None, None, ), # 4
  )

  def __init__(self, tuple_id=None, result_expr_lists=None, const_expr_lists=None, first_materialized_child_idx=None,):
    self.tuple_id = tuple_id
    self.result_expr_lists = result_expr_lists
    self.const_expr_lists = const_expr_lists
    self.first_materialized_child_idx = first_materialized_child_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.result_expr_lists = []
          (_etype170, _size167) = iprot.readListBegin()
          for _i171 in xrange(_size167):
            _elem172 = []
            (_etype176, _size173) = iprot.readListBegin()
            for _i177 in xrange(_size173):
              _elem178 = Exprs.ttypes.TExpr()
              _elem178.read(iprot)
              _elem172.append(_elem178)
            iprot.readListEnd()
            self.result_expr_lists.append(_elem172)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.const_expr_lists = []
          (_etype182, _size179) = iprot.readListBegin()
          for _i183 in xrange(_size179):
            _elem184 = []
            (_etype188, _size185) = iprot.readListBegin()
            for _i189 in xrange(_size185):
              _elem190 = Exprs.ttypes.TExpr()
              _elem190.read(iprot)
              _elem184.append(_elem190)
            iprot.readListEnd()
            self.const_expr_lists.append(_elem184)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.first_materialized_child_idx = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUnionNode')
    if self.tuple_id is not None:
      oprot.writeFieldBegin('tuple_id', TType.I32, 1)
      oprot.writeI32(self.tuple_id)
      oprot.writeFieldEnd()
    if self.result_expr_lists is not None:
      oprot.writeFieldBegin('result_expr_lists', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.result_expr_lists))
      for iter191 in self.result_expr_lists:
        oprot.writeListBegin(TType.STRUCT, len(iter191))
        for iter192 in iter191:
          iter192.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.const_expr_lists is not None:
      oprot.writeFieldBegin('const_expr_lists', TType.LIST, 3)
      oprot.writeListBegin(TType.LIST, len(self.const_expr_lists))
      for iter193 in self.const_expr_lists:
        oprot.writeListBegin(TType.STRUCT, len(iter193))
        for iter194 in iter193:
          iter194.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.first_materialized_child_idx is not None:
      oprot.writeFieldBegin('first_materialized_child_idx', TType.I64, 4)
      oprot.writeI64(self.first_materialized_child_idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field tuple_id is unset!')
    if self.result_expr_lists is None:
      raise TProtocol.TProtocolException(message='Required field result_expr_lists is unset!')
    if self.const_expr_lists is None:
      raise TProtocol.TProtocolException(message='Required field const_expr_lists is unset!')
    if self.first_materialized_child_idx is None:
      raise TProtocol.TProtocolException(message='Required field first_materialized_child_idx is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExchangeNode:
  """
  Attributes:
   - input_row_tuples
   - sort_info
   - offset
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'input_row_tuples', (TType.I32,None), None, ), # 1
    (2, TType.STRUCT, 'sort_info', (TSortInfo, TSortInfo.thrift_spec), None, ), # 2
    (3, TType.I64, 'offset', None, None, ), # 3
  )

  def __init__(self, input_row_tuples=None, sort_info=None, offset=None,):
    self.input_row_tuples = input_row_tuples
    self.sort_info = sort_info
    self.offset = offset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.input_row_tuples = []
          (_etype198, _size195) = iprot.readListBegin()
          for _i199 in xrange(_size195):
            _elem200 = iprot.readI32();
            self.input_row_tuples.append(_elem200)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sort_info = TSortInfo()
          self.sort_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.offset = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExchangeNode')
    if self.input_row_tuples is not None:
      oprot.writeFieldBegin('input_row_tuples', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.input_row_tuples))
      for iter201 in self.input_row_tuples:
        oprot.writeI32(iter201)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sort_info is not None:
      oprot.writeFieldBegin('sort_info', TType.STRUCT, 2)
      self.sort_info.write(oprot)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I64, 3)
      oprot.writeI64(self.offset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.input_row_tuples is None:
      raise TProtocol.TProtocolException(message='Required field input_row_tuples is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUnnestNode:
  """
  Attributes:
   - collection_expr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'collection_expr', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 1
  )

  def __init__(self, collection_expr=None,):
    self.collection_expr = collection_expr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.collection_expr = Exprs.ttypes.TExpr()
          self.collection_expr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUnnestNode')
    if self.collection_expr is not None:
      oprot.writeFieldBegin('collection_expr', TType.STRUCT, 1)
      self.collection_expr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.collection_expr is None:
      raise TProtocol.TProtocolException(message='Required field collection_expr is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TBackendResourceProfile:
  """
  Attributes:
   - min_reservation
   - max_reservation
   - spillable_buffer_size
   - max_row_buffer_size
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'min_reservation', None, None, ), # 1
    (2, TType.I64, 'max_reservation', None, None, ), # 2
    (3, TType.I64, 'spillable_buffer_size', None, None, ), # 3
    (4, TType.I64, 'max_row_buffer_size', None, None, ), # 4
  )

  def __init__(self, min_reservation=None, max_reservation=None, spillable_buffer_size=None, max_row_buffer_size=None,):
    self.min_reservation = min_reservation
    self.max_reservation = max_reservation
    self.spillable_buffer_size = spillable_buffer_size
    self.max_row_buffer_size = max_row_buffer_size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.min_reservation = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.max_reservation = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.spillable_buffer_size = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.max_row_buffer_size = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TBackendResourceProfile')
    if self.min_reservation is not None:
      oprot.writeFieldBegin('min_reservation', TType.I64, 1)
      oprot.writeI64(self.min_reservation)
      oprot.writeFieldEnd()
    if self.max_reservation is not None:
      oprot.writeFieldBegin('max_reservation', TType.I64, 2)
      oprot.writeI64(self.max_reservation)
      oprot.writeFieldEnd()
    if self.spillable_buffer_size is not None:
      oprot.writeFieldBegin('spillable_buffer_size', TType.I64, 3)
      oprot.writeI64(self.spillable_buffer_size)
      oprot.writeFieldEnd()
    if self.max_row_buffer_size is not None:
      oprot.writeFieldBegin('max_row_buffer_size', TType.I64, 4)
      oprot.writeI64(self.max_row_buffer_size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.min_reservation is None:
      raise TProtocol.TProtocolException(message='Required field min_reservation is unset!')
    if self.max_reservation is None:
      raise TProtocol.TProtocolException(message='Required field max_reservation is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanNode:
  """
  Attributes:
   - node_id
   - node_type
   - num_children
   - limit
   - row_tuples
   - nullable_tuples
   - conjuncts
   - disable_codegen
   - hdfs_scan_node
   - hbase_scan_node
   - kudu_scan_node
   - data_source_node
   - hash_join_node
   - nested_loop_join_node
   - agg_node
   - sort_node
   - union_node
   - exchange_node
   - analytic_node
   - unnest_node
   - label
   - label_detail
   - estimated_stats
   - runtime_filters
   - resource_profile
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'node_id', None, None, ), # 1
    (2, TType.I32, 'node_type', None, None, ), # 2
    (3, TType.I32, 'num_children', None, None, ), # 3
    (4, TType.I64, 'limit', None, None, ), # 4
    (5, TType.LIST, 'row_tuples', (TType.I32,None), None, ), # 5
    (6, TType.LIST, 'nullable_tuples', (TType.BOOL,None), None, ), # 6
    (7, TType.LIST, 'conjuncts', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 7
    (8, TType.BOOL, 'disable_codegen', None, None, ), # 8
    (9, TType.STRUCT, 'hdfs_scan_node', (THdfsScanNode, THdfsScanNode.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'hbase_scan_node', (THBaseScanNode, THBaseScanNode.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'kudu_scan_node', (TKuduScanNode, TKuduScanNode.thrift_spec), None, ), # 11
    (12, TType.STRUCT, 'data_source_node', (TDataSourceScanNode, TDataSourceScanNode.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'hash_join_node', (THashJoinNode, THashJoinNode.thrift_spec), None, ), # 13
    (14, TType.STRUCT, 'nested_loop_join_node', (TNestedLoopJoinNode, TNestedLoopJoinNode.thrift_spec), None, ), # 14
    (15, TType.STRUCT, 'agg_node', (TAggregationNode, TAggregationNode.thrift_spec), None, ), # 15
    (16, TType.STRUCT, 'sort_node', (TSortNode, TSortNode.thrift_spec), None, ), # 16
    (17, TType.STRUCT, 'union_node', (TUnionNode, TUnionNode.thrift_spec), None, ), # 17
    (18, TType.STRUCT, 'exchange_node', (TExchangeNode, TExchangeNode.thrift_spec), None, ), # 18
    (19, TType.STRUCT, 'analytic_node', (TAnalyticNode, TAnalyticNode.thrift_spec), None, ), # 19
    (20, TType.STRUCT, 'unnest_node', (TUnnestNode, TUnnestNode.thrift_spec), None, ), # 20
    (21, TType.STRING, 'label', None, None, ), # 21
    (22, TType.STRING, 'label_detail', None, None, ), # 22
    (23, TType.STRUCT, 'estimated_stats', (ExecStats.ttypes.TExecStats, ExecStats.ttypes.TExecStats.thrift_spec), None, ), # 23
    (24, TType.LIST, 'runtime_filters', (TType.STRUCT,(TRuntimeFilterDesc, TRuntimeFilterDesc.thrift_spec)), None, ), # 24
    (25, TType.STRUCT, 'resource_profile', (TBackendResourceProfile, TBackendResourceProfile.thrift_spec), None, ), # 25
  )

  def __init__(self, node_id=None, node_type=None, num_children=None, limit=None, row_tuples=None, nullable_tuples=None, conjuncts=None, disable_codegen=None, hdfs_scan_node=None, hbase_scan_node=None, kudu_scan_node=None, data_source_node=None, hash_join_node=None, nested_loop_join_node=None, agg_node=None, sort_node=None, union_node=None, exchange_node=None, analytic_node=None, unnest_node=None, label=None, label_detail=None, estimated_stats=None, runtime_filters=None, resource_profile=None,):
    self.node_id = node_id
    self.node_type = node_type
    self.num_children = num_children
    self.limit = limit
    self.row_tuples = row_tuples
    self.nullable_tuples = nullable_tuples
    self.conjuncts = conjuncts
    self.disable_codegen = disable_codegen
    self.hdfs_scan_node = hdfs_scan_node
    self.hbase_scan_node = hbase_scan_node
    self.kudu_scan_node = kudu_scan_node
    self.data_source_node = data_source_node
    self.hash_join_node = hash_join_node
    self.nested_loop_join_node = nested_loop_join_node
    self.agg_node = agg_node
    self.sort_node = sort_node
    self.union_node = union_node
    self.exchange_node = exchange_node
    self.analytic_node = analytic_node
    self.unnest_node = unnest_node
    self.label = label
    self.label_detail = label_detail
    self.estimated_stats = estimated_stats
    self.runtime_filters = runtime_filters
    self.resource_profile = resource_profile

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.node_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.node_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.num_children = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.row_tuples = []
          (_etype205, _size202) = iprot.readListBegin()
          for _i206 in xrange(_size202):
            _elem207 = iprot.readI32();
            self.row_tuples.append(_elem207)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.nullable_tuples = []
          (_etype211, _size208) = iprot.readListBegin()
          for _i212 in xrange(_size208):
            _elem213 = iprot.readBool();
            self.nullable_tuples.append(_elem213)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.conjuncts = []
          (_etype217, _size214) = iprot.readListBegin()
          for _i218 in xrange(_size214):
            _elem219 = Exprs.ttypes.TExpr()
            _elem219.read(iprot)
            self.conjuncts.append(_elem219)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.disable_codegen = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.hdfs_scan_node = THdfsScanNode()
          self.hdfs_scan_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.hbase_scan_node = THBaseScanNode()
          self.hbase_scan_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.kudu_scan_node = TKuduScanNode()
          self.kudu_scan_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.data_source_node = TDataSourceScanNode()
          self.data_source_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.hash_join_node = THashJoinNode()
          self.hash_join_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.nested_loop_join_node = TNestedLoopJoinNode()
          self.nested_loop_join_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.agg_node = TAggregationNode()
          self.agg_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.sort_node = TSortNode()
          self.sort_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.union_node = TUnionNode()
          self.union_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRUCT:
          self.exchange_node = TExchangeNode()
          self.exchange_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRUCT:
          self.analytic_node = TAnalyticNode()
          self.analytic_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRUCT:
          self.unnest_node = TUnnestNode()
          self.unnest_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRING:
          self.label = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRING:
          self.label_detail = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRUCT:
          self.estimated_stats = ExecStats.ttypes.TExecStats()
          self.estimated_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.LIST:
          self.runtime_filters = []
          (_etype223, _size220) = iprot.readListBegin()
          for _i224 in xrange(_size220):
            _elem225 = TRuntimeFilterDesc()
            _elem225.read(iprot)
            self.runtime_filters.append(_elem225)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.STRUCT:
          self.resource_profile = TBackendResourceProfile()
          self.resource_profile.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanNode')
    if self.node_id is not None:
      oprot.writeFieldBegin('node_id', TType.I32, 1)
      oprot.writeI32(self.node_id)
      oprot.writeFieldEnd()
    if self.node_type is not None:
      oprot.writeFieldBegin('node_type', TType.I32, 2)
      oprot.writeI32(self.node_type)
      oprot.writeFieldEnd()
    if self.num_children is not None:
      oprot.writeFieldBegin('num_children', TType.I32, 3)
      oprot.writeI32(self.num_children)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I64, 4)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.row_tuples is not None:
      oprot.writeFieldBegin('row_tuples', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.row_tuples))
      for iter226 in self.row_tuples:
        oprot.writeI32(iter226)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nullable_tuples is not None:
      oprot.writeFieldBegin('nullable_tuples', TType.LIST, 6)
      oprot.writeListBegin(TType.BOOL, len(self.nullable_tuples))
      for iter227 in self.nullable_tuples:
        oprot.writeBool(iter227)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.conjuncts is not None:
      oprot.writeFieldBegin('conjuncts', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.conjuncts))
      for iter228 in self.conjuncts:
        iter228.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.disable_codegen is not None:
      oprot.writeFieldBegin('disable_codegen', TType.BOOL, 8)
      oprot.writeBool(self.disable_codegen)
      oprot.writeFieldEnd()
    if self.hdfs_scan_node is not None:
      oprot.writeFieldBegin('hdfs_scan_node', TType.STRUCT, 9)
      self.hdfs_scan_node.write(oprot)
      oprot.writeFieldEnd()
    if self.hbase_scan_node is not None:
      oprot.writeFieldBegin('hbase_scan_node', TType.STRUCT, 10)
      self.hbase_scan_node.write(oprot)
      oprot.writeFieldEnd()
    if self.kudu_scan_node is not None:
      oprot.writeFieldBegin('kudu_scan_node', TType.STRUCT, 11)
      self.kudu_scan_node.write(oprot)
      oprot.writeFieldEnd()
    if self.data_source_node is not None:
      oprot.writeFieldBegin('data_source_node', TType.STRUCT, 12)
      self.data_source_node.write(oprot)
      oprot.writeFieldEnd()
    if self.hash_join_node is not None:
      oprot.writeFieldBegin('hash_join_node', TType.STRUCT, 13)
      self.hash_join_node.write(oprot)
      oprot.writeFieldEnd()
    if self.nested_loop_join_node is not None:
      oprot.writeFieldBegin('nested_loop_join_node', TType.STRUCT, 14)
      self.nested_loop_join_node.write(oprot)
      oprot.writeFieldEnd()
    if self.agg_node is not None:
      oprot.writeFieldBegin('agg_node', TType.STRUCT, 15)
      self.agg_node.write(oprot)
      oprot.writeFieldEnd()
    if self.sort_node is not None:
      oprot.writeFieldBegin('sort_node', TType.STRUCT, 16)
      self.sort_node.write(oprot)
      oprot.writeFieldEnd()
    if self.union_node is not None:
      oprot.writeFieldBegin('union_node', TType.STRUCT, 17)
      self.union_node.write(oprot)
      oprot.writeFieldEnd()
    if self.exchange_node is not None:
      oprot.writeFieldBegin('exchange_node', TType.STRUCT, 18)
      self.exchange_node.write(oprot)
      oprot.writeFieldEnd()
    if self.analytic_node is not None:
      oprot.writeFieldBegin('analytic_node', TType.STRUCT, 19)
      self.analytic_node.write(oprot)
      oprot.writeFieldEnd()
    if self.unnest_node is not None:
      oprot.writeFieldBegin('unnest_node', TType.STRUCT, 20)
      self.unnest_node.write(oprot)
      oprot.writeFieldEnd()
    if self.label is not None:
      oprot.writeFieldBegin('label', TType.STRING, 21)
      oprot.writeString(self.label)
      oprot.writeFieldEnd()
    if self.label_detail is not None:
      oprot.writeFieldBegin('label_detail', TType.STRING, 22)
      oprot.writeString(self.label_detail)
      oprot.writeFieldEnd()
    if self.estimated_stats is not None:
      oprot.writeFieldBegin('estimated_stats', TType.STRUCT, 23)
      self.estimated_stats.write(oprot)
      oprot.writeFieldEnd()
    if self.runtime_filters is not None:
      oprot.writeFieldBegin('runtime_filters', TType.LIST, 24)
      oprot.writeListBegin(TType.STRUCT, len(self.runtime_filters))
      for iter229 in self.runtime_filters:
        iter229.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.resource_profile is not None:
      oprot.writeFieldBegin('resource_profile', TType.STRUCT, 25)
      self.resource_profile.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.node_id is None:
      raise TProtocol.TProtocolException(message='Required field node_id is unset!')
    if self.node_type is None:
      raise TProtocol.TProtocolException(message='Required field node_type is unset!')
    if self.num_children is None:
      raise TProtocol.TProtocolException(message='Required field num_children is unset!')
    if self.limit is None:
      raise TProtocol.TProtocolException(message='Required field limit is unset!')
    if self.row_tuples is None:
      raise TProtocol.TProtocolException(message='Required field row_tuples is unset!')
    if self.nullable_tuples is None:
      raise TProtocol.TProtocolException(message='Required field nullable_tuples is unset!')
    if self.disable_codegen is None:
      raise TProtocol.TProtocolException(message='Required field disable_codegen is unset!')
    if self.resource_profile is None:
      raise TProtocol.TProtocolException(message='Required field resource_profile is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlan:
  """
  Attributes:
   - nodes
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'nodes', (TType.STRUCT,(TPlanNode, TPlanNode.thrift_spec)), None, ), # 1
  )

  def __init__(self, nodes=None,):
    self.nodes = nodes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.nodes = []
          (_etype233, _size230) = iprot.readListBegin()
          for _i234 in xrange(_size230):
            _elem235 = TPlanNode()
            _elem235.read(iprot)
            self.nodes.append(_elem235)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlan')
    if self.nodes is not None:
      oprot.writeFieldBegin('nodes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.nodes))
      for iter236 in self.nodes:
        iter236.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.nodes is None:
      raise TProtocol.TProtocolException(message='Required field nodes is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
