#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Types.ttypes
import ImpalaInternalService.ttypes
import PlanNodes.ttypes
import Planner.ttypes
import RuntimeProfile.ttypes
import Descriptors.ttypes
import Data.ttypes
import Results.ttypes
import Exprs.ttypes
import TCLIService.ttypes
import Status.ttypes
import CatalogObjects.ttypes
import CatalogService.ttypes
import LineageGraph.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TDescribeOutputStyle:
  MINIMAL = 0
  EXTENDED = 1
  FORMATTED = 2

  _VALUES_TO_NAMES = {
    0: "MINIMAL",
    1: "EXTENDED",
    2: "FORMATTED",
  }

  _NAMES_TO_VALUES = {
    "MINIMAL": 0,
    "EXTENDED": 1,
    "FORMATTED": 2,
  }

class TShowStatsOp:
  TABLE_STATS = 0
  COLUMN_STATS = 1
  PARTITIONS = 2
  RANGE_PARTITIONS = 3

  _VALUES_TO_NAMES = {
    0: "TABLE_STATS",
    1: "COLUMN_STATS",
    2: "PARTITIONS",
    3: "RANGE_PARTITIONS",
  }

  _NAMES_TO_VALUES = {
    "TABLE_STATS": 0,
    "COLUMN_STATS": 1,
    "PARTITIONS": 2,
    "RANGE_PARTITIONS": 3,
  }

class TCatalogOpType:
  SHOW_TABLES = 0
  SHOW_DBS = 1
  SHOW_STATS = 2
  USE = 3
  DESCRIBE_TABLE = 4
  DESCRIBE_DB = 5
  SHOW_FUNCTIONS = 6
  RESET_METADATA = 7
  DDL = 8
  SHOW_CREATE_TABLE = 9
  SHOW_DATA_SRCS = 10
  SHOW_ROLES = 11
  SHOW_GRANT_ROLE = 12
  SHOW_FILES = 13
  SHOW_CREATE_FUNCTION = 14

  _VALUES_TO_NAMES = {
    0: "SHOW_TABLES",
    1: "SHOW_DBS",
    2: "SHOW_STATS",
    3: "USE",
    4: "DESCRIBE_TABLE",
    5: "DESCRIBE_DB",
    6: "SHOW_FUNCTIONS",
    7: "RESET_METADATA",
    8: "DDL",
    9: "SHOW_CREATE_TABLE",
    10: "SHOW_DATA_SRCS",
    11: "SHOW_ROLES",
    12: "SHOW_GRANT_ROLE",
    13: "SHOW_FILES",
    14: "SHOW_CREATE_FUNCTION",
  }

  _NAMES_TO_VALUES = {
    "SHOW_TABLES": 0,
    "SHOW_DBS": 1,
    "SHOW_STATS": 2,
    "USE": 3,
    "DESCRIBE_TABLE": 4,
    "DESCRIBE_DB": 5,
    "SHOW_FUNCTIONS": 6,
    "RESET_METADATA": 7,
    "DDL": 8,
    "SHOW_CREATE_TABLE": 9,
    "SHOW_DATA_SRCS": 10,
    "SHOW_ROLES": 11,
    "SHOW_GRANT_ROLE": 12,
    "SHOW_FILES": 13,
    "SHOW_CREATE_FUNCTION": 14,
  }

class TMetadataOpcode:
  GET_TYPE_INFO = 0
  GET_CATALOGS = 1
  GET_SCHEMAS = 2
  GET_TABLES = 3
  GET_TABLE_TYPES = 4
  GET_COLUMNS = 5
  GET_FUNCTIONS = 6

  _VALUES_TO_NAMES = {
    0: "GET_TYPE_INFO",
    1: "GET_CATALOGS",
    2: "GET_SCHEMAS",
    3: "GET_TABLES",
    4: "GET_TABLE_TYPES",
    5: "GET_COLUMNS",
    6: "GET_FUNCTIONS",
  }

  _NAMES_TO_VALUES = {
    "GET_TYPE_INFO": 0,
    "GET_CATALOGS": 1,
    "GET_SCHEMAS": 2,
    "GET_TABLES": 3,
    "GET_TABLE_TYPES": 4,
    "GET_COLUMNS": 5,
    "GET_FUNCTIONS": 6,
  }

class TSymbolType:
  UDF_EVALUATE = 0
  UDF_PREPARE = 1
  UDF_CLOSE = 2

  _VALUES_TO_NAMES = {
    0: "UDF_EVALUATE",
    1: "UDF_PREPARE",
    2: "UDF_CLOSE",
  }

  _NAMES_TO_VALUES = {
    "UDF_EVALUATE": 0,
    "UDF_PREPARE": 1,
    "UDF_CLOSE": 2,
  }

class TSymbolLookupResultCode:
  SYMBOL_FOUND = 0
  BINARY_NOT_FOUND = 1
  SYMBOL_NOT_FOUND = 2

  _VALUES_TO_NAMES = {
    0: "SYMBOL_FOUND",
    1: "BINARY_NOT_FOUND",
    2: "SYMBOL_NOT_FOUND",
  }

  _NAMES_TO_VALUES = {
    "SYMBOL_FOUND": 0,
    "BINARY_NOT_FOUND": 1,
    "SYMBOL_NOT_FOUND": 2,
  }


class THiveUdfExecutorCtorParams:
  """
  Attributes:
   - fn
   - local_location
   - input_byte_offsets
   - input_nulls_ptr
   - input_buffer_ptr
   - output_null_ptr
   - output_buffer_ptr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fn', (Types.ttypes.TFunction, Types.ttypes.TFunction.thrift_spec), None, ), # 1
    (2, TType.STRING, 'local_location', None, None, ), # 2
    (3, TType.LIST, 'input_byte_offsets', (TType.I32,None), None, ), # 3
    (4, TType.I64, 'input_nulls_ptr', None, None, ), # 4
    (5, TType.I64, 'input_buffer_ptr', None, None, ), # 5
    (6, TType.I64, 'output_null_ptr', None, None, ), # 6
    (7, TType.I64, 'output_buffer_ptr', None, None, ), # 7
  )

  def __init__(self, fn=None, local_location=None, input_byte_offsets=None, input_nulls_ptr=None, input_buffer_ptr=None, output_null_ptr=None, output_buffer_ptr=None,):
    self.fn = fn
    self.local_location = local_location
    self.input_byte_offsets = input_byte_offsets
    self.input_nulls_ptr = input_nulls_ptr
    self.input_buffer_ptr = input_buffer_ptr
    self.output_null_ptr = output_null_ptr
    self.output_buffer_ptr = output_buffer_ptr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fn = Types.ttypes.TFunction()
          self.fn.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.local_location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.input_byte_offsets = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32();
            self.input_byte_offsets.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.input_nulls_ptr = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.input_buffer_ptr = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.output_null_ptr = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.output_buffer_ptr = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THiveUdfExecutorCtorParams')
    if self.fn is not None:
      oprot.writeFieldBegin('fn', TType.STRUCT, 1)
      self.fn.write(oprot)
      oprot.writeFieldEnd()
    if self.local_location is not None:
      oprot.writeFieldBegin('local_location', TType.STRING, 2)
      oprot.writeString(self.local_location)
      oprot.writeFieldEnd()
    if self.input_byte_offsets is not None:
      oprot.writeFieldBegin('input_byte_offsets', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.input_byte_offsets))
      for iter6 in self.input_byte_offsets:
        oprot.writeI32(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.input_nulls_ptr is not None:
      oprot.writeFieldBegin('input_nulls_ptr', TType.I64, 4)
      oprot.writeI64(self.input_nulls_ptr)
      oprot.writeFieldEnd()
    if self.input_buffer_ptr is not None:
      oprot.writeFieldBegin('input_buffer_ptr', TType.I64, 5)
      oprot.writeI64(self.input_buffer_ptr)
      oprot.writeFieldEnd()
    if self.output_null_ptr is not None:
      oprot.writeFieldBegin('output_null_ptr', TType.I64, 6)
      oprot.writeI64(self.output_null_ptr)
      oprot.writeFieldEnd()
    if self.output_buffer_ptr is not None:
      oprot.writeFieldBegin('output_buffer_ptr', TType.I64, 7)
      oprot.writeI64(self.output_buffer_ptr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fn is None:
      raise TProtocol.TProtocolException(message='Required field fn is unset!')
    if self.local_location is None:
      raise TProtocol.TProtocolException(message='Required field local_location is unset!')
    if self.input_byte_offsets is None:
      raise TProtocol.TProtocolException(message='Required field input_byte_offsets is unset!')
    if self.input_nulls_ptr is None:
      raise TProtocol.TProtocolException(message='Required field input_nulls_ptr is unset!')
    if self.input_buffer_ptr is None:
      raise TProtocol.TProtocolException(message='Required field input_buffer_ptr is unset!')
    if self.output_null_ptr is None:
      raise TProtocol.TProtocolException(message='Required field output_null_ptr is unset!')
    if self.output_buffer_ptr is None:
      raise TProtocol.TProtocolException(message='Required field output_buffer_ptr is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetTablesParams:
  """
  Attributes:
   - db
   - pattern
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'pattern', None, None, ), # 2
    (3, TType.STRUCT, 'session', (ImpalaInternalService.ttypes.TSessionState, ImpalaInternalService.ttypes.TSessionState.thrift_spec), None, ), # 3
  )

  def __init__(self, db=None, pattern=None, session=None,):
    self.db = db
    self.pattern = pattern
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = ImpalaInternalService.ttypes.TSessionState()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTablesParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 2)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetTablesResult:
  """
  Attributes:
   - tables
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tables', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, tables=None,):
    self.tables = tables

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tables = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.tables.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTablesResult')
    if self.tables is not None:
      oprot.writeFieldBegin('tables', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.tables))
      for iter13 in self.tables:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetDbsParams:
  """
  Attributes:
   - pattern
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pattern', None, None, ), # 1
    (2, TType.STRUCT, 'session', (ImpalaInternalService.ttypes.TSessionState, ImpalaInternalService.ttypes.TSessionState.thrift_spec), None, ), # 2
  )

  def __init__(self, pattern=None, session=None,):
    self.pattern = pattern
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = ImpalaInternalService.ttypes.TSessionState()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetDbsParams')
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 1)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetDbsResult:
  """
  Attributes:
   - dbs
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'dbs', (TType.STRUCT,(CatalogObjects.ttypes.TDatabase, CatalogObjects.ttypes.TDatabase.thrift_spec)), None, ), # 1
  )

  def __init__(self, dbs=None,):
    self.dbs = dbs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.dbs = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = CatalogObjects.ttypes.TDatabase()
            _elem19.read(iprot)
            self.dbs.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetDbsResult')
    if self.dbs is not None:
      oprot.writeFieldBegin('dbs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.dbs))
      for iter20 in self.dbs:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetDataSrcsParams:
  """
  Attributes:
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pattern', None, None, ), # 1
  )

  def __init__(self, pattern=None,):
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetDataSrcsParams')
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 1)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetDataSrcsResult:
  """
  Attributes:
   - data_src_names
   - locations
   - class_names
   - api_versions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'data_src_names', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'locations', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'class_names', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'api_versions', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, data_src_names=None, locations=None, class_names=None, api_versions=None,):
    self.data_src_names = data_src_names
    self.locations = locations
    self.class_names = class_names
    self.api_versions = api_versions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.data_src_names = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readString();
            self.data_src_names.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.locations = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = iprot.readString();
            self.locations.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.class_names = []
          (_etype36, _size33) = iprot.readListBegin()
          for _i37 in xrange(_size33):
            _elem38 = iprot.readString();
            self.class_names.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.api_versions = []
          (_etype42, _size39) = iprot.readListBegin()
          for _i43 in xrange(_size39):
            _elem44 = iprot.readString();
            self.api_versions.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetDataSrcsResult')
    if self.data_src_names is not None:
      oprot.writeFieldBegin('data_src_names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.data_src_names))
      for iter45 in self.data_src_names:
        oprot.writeString(iter45)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.locations is not None:
      oprot.writeFieldBegin('locations', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.locations))
      for iter46 in self.locations:
        oprot.writeString(iter46)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.class_names is not None:
      oprot.writeFieldBegin('class_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.class_names))
      for iter47 in self.class_names:
        oprot.writeString(iter47)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.api_versions is not None:
      oprot.writeFieldBegin('api_versions', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.api_versions))
      for iter48 in self.api_versions:
        oprot.writeString(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.data_src_names is None:
      raise TProtocol.TProtocolException(message='Required field data_src_names is unset!')
    if self.locations is None:
      raise TProtocol.TProtocolException(message='Required field locations is unset!')
    if self.class_names is None:
      raise TProtocol.TProtocolException(message='Required field class_names is unset!')
    if self.api_versions is None:
      raise TProtocol.TProtocolException(message='Required field api_versions is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDescribeDbParams:
  """
  Attributes:
   - db
   - output_style
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.I32, 'output_style', None, None, ), # 2
  )

  def __init__(self, db=None, output_style=None,):
    self.db = db
    self.output_style = output_style

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.output_style = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDescribeDbParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.output_style is not None:
      oprot.writeFieldBegin('output_style', TType.I32, 2)
      oprot.writeI32(self.output_style)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db is None:
      raise TProtocol.TProtocolException(message='Required field db is unset!')
    if self.output_style is None:
      raise TProtocol.TProtocolException(message='Required field output_style is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDescribeTableParams:
  """
  Attributes:
   - output_style
   - table_name
   - result_struct
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'output_style', None, None, ), # 1
    (2, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'result_struct', (Types.ttypes.TColumnType, Types.ttypes.TColumnType.thrift_spec), None, ), # 3
  )

  def __init__(self, output_style=None, table_name=None, result_struct=None,):
    self.output_style = output_style
    self.table_name = table_name
    self.result_struct = result_struct

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.output_style = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.result_struct = Types.ttypes.TColumnType()
          self.result_struct.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDescribeTableParams')
    if self.output_style is not None:
      oprot.writeFieldBegin('output_style', TType.I32, 1)
      oprot.writeI32(self.output_style)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.result_struct is not None:
      oprot.writeFieldBegin('result_struct', TType.STRUCT, 3)
      self.result_struct.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.output_style is None:
      raise TProtocol.TProtocolException(message='Required field output_style is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDescribeResult:
  """
  Attributes:
   - results
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'results', (TType.STRUCT,(Data.ttypes.TResultRow, Data.ttypes.TResultRow.thrift_spec)), None, ), # 1
  )

  def __init__(self, results=None,):
    self.results = results

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.results = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = Data.ttypes.TResultRow()
            _elem54.read(iprot)
            self.results.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDescribeResult')
    if self.results is not None:
      oprot.writeFieldBegin('results', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.results))
      for iter55 in self.results:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.results is None:
      raise TProtocol.TProtocolException(message='Required field results is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowDataSrcsParams:
  """
  Attributes:
   - show_pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'show_pattern', None, None, ), # 1
  )

  def __init__(self, show_pattern=None,):
    self.show_pattern = show_pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.show_pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowDataSrcsParams')
    if self.show_pattern is not None:
      oprot.writeFieldBegin('show_pattern', TType.STRING, 1)
      oprot.writeString(self.show_pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowDbsParams:
  """
  Attributes:
   - show_pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'show_pattern', None, None, ), # 1
  )

  def __init__(self, show_pattern=None,):
    self.show_pattern = show_pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.show_pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowDbsParams')
    if self.show_pattern is not None:
      oprot.writeFieldBegin('show_pattern', TType.STRING, 1)
      oprot.writeString(self.show_pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowStatsParams:
  """
  Attributes:
   - op
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'op', None, None, ), # 1
    (2, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 2
  )

  def __init__(self, op=None, table_name=None,):
    self.op = op
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.op = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowStatsParams')
    if self.op is not None:
      oprot.writeFieldBegin('op', TType.I32, 1)
      oprot.writeI32(self.op)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowFunctionsParams:
  """
  Attributes:
   - category
   - db
   - show_pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'category', None, None, ), # 1
    (2, TType.STRING, 'db', None, None, ), # 2
    (3, TType.STRING, 'show_pattern', None, None, ), # 3
  )

  def __init__(self, category=None, db=None, show_pattern=None,):
    self.category = category
    self.db = db
    self.show_pattern = show_pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.category = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.show_pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowFunctionsParams')
    if self.category is not None:
      oprot.writeFieldBegin('category', TType.I32, 1)
      oprot.writeI32(self.category)
      oprot.writeFieldEnd()
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 2)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.show_pattern is not None:
      oprot.writeFieldBegin('show_pattern', TType.STRING, 3)
      oprot.writeString(self.show_pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowTablesParams:
  """
  Attributes:
   - db
   - show_pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'show_pattern', None, None, ), # 2
  )

  def __init__(self, db=None, show_pattern=None,):
    self.db = db
    self.show_pattern = show_pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.show_pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowTablesParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.show_pattern is not None:
      oprot.writeFieldBegin('show_pattern', TType.STRING, 2)
      oprot.writeString(self.show_pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowFilesParams:
  """
  Attributes:
   - table_name
   - partition_set
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.LIST, 'partition_set', (TType.LIST,(TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec))), None, ), # 2
  )

  def __init__(self, table_name=None, partition_set=None,):
    self.table_name = table_name
    self.partition_set = partition_set

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partition_set = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = []
            (_etype65, _size62) = iprot.readListBegin()
            for _i66 in xrange(_size62):
              _elem67 = CatalogObjects.ttypes.TPartitionKeyValue()
              _elem67.read(iprot)
              _elem61.append(_elem67)
            iprot.readListEnd()
            self.partition_set.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowFilesParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.partition_set is not None:
      oprot.writeFieldBegin('partition_set', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.partition_set))
      for iter68 in self.partition_set:
        oprot.writeListBegin(TType.STRUCT, len(iter68))
        for iter69 in iter68:
          iter69.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowRolesParams:
  """
  Attributes:
   - requesting_user
   - is_admin_op
   - is_show_current_roles
   - grant_group
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'requesting_user', None, None, ), # 1
    (2, TType.BOOL, 'is_admin_op', None, None, ), # 2
    (3, TType.BOOL, 'is_show_current_roles', None, None, ), # 3
    (4, TType.STRING, 'grant_group', None, None, ), # 4
  )

  def __init__(self, requesting_user=None, is_admin_op=None, is_show_current_roles=None, grant_group=None,):
    self.requesting_user = requesting_user
    self.is_admin_op = is_admin_op
    self.is_show_current_roles = is_show_current_roles
    self.grant_group = grant_group

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.requesting_user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.is_admin_op = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_show_current_roles = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.grant_group = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowRolesParams')
    if self.requesting_user is not None:
      oprot.writeFieldBegin('requesting_user', TType.STRING, 1)
      oprot.writeString(self.requesting_user)
      oprot.writeFieldEnd()
    if self.is_admin_op is not None:
      oprot.writeFieldBegin('is_admin_op', TType.BOOL, 2)
      oprot.writeBool(self.is_admin_op)
      oprot.writeFieldEnd()
    if self.is_show_current_roles is not None:
      oprot.writeFieldBegin('is_show_current_roles', TType.BOOL, 3)
      oprot.writeBool(self.is_show_current_roles)
      oprot.writeFieldEnd()
    if self.grant_group is not None:
      oprot.writeFieldBegin('grant_group', TType.STRING, 4)
      oprot.writeString(self.grant_group)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.is_admin_op is None:
      raise TProtocol.TProtocolException(message='Required field is_admin_op is unset!')
    if self.is_show_current_roles is None:
      raise TProtocol.TProtocolException(message='Required field is_show_current_roles is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowRolesResult:
  """
  Attributes:
   - role_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'role_names', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, role_names=None,):
    self.role_names = role_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.role_names = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = iprot.readString();
            self.role_names.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowRolesResult')
    if self.role_names is not None:
      oprot.writeFieldBegin('role_names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.role_names))
      for iter76 in self.role_names:
        oprot.writeString(iter76)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.role_names is None:
      raise TProtocol.TProtocolException(message='Required field role_names is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowGrantRoleParams:
  """
  Attributes:
   - requesting_user
   - role_name
   - is_admin_op
   - privilege
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'requesting_user', None, None, ), # 1
    (2, TType.STRING, 'role_name', None, None, ), # 2
    (3, TType.BOOL, 'is_admin_op', None, None, ), # 3
    (4, TType.STRUCT, 'privilege', (CatalogObjects.ttypes.TPrivilege, CatalogObjects.ttypes.TPrivilege.thrift_spec), None, ), # 4
  )

  def __init__(self, requesting_user=None, role_name=None, is_admin_op=None, privilege=None,):
    self.requesting_user = requesting_user
    self.role_name = role_name
    self.is_admin_op = is_admin_op
    self.privilege = privilege

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.requesting_user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.role_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_admin_op = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.privilege = CatalogObjects.ttypes.TPrivilege()
          self.privilege.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowGrantRoleParams')
    if self.requesting_user is not None:
      oprot.writeFieldBegin('requesting_user', TType.STRING, 1)
      oprot.writeString(self.requesting_user)
      oprot.writeFieldEnd()
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 2)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    if self.is_admin_op is not None:
      oprot.writeFieldBegin('is_admin_op', TType.BOOL, 3)
      oprot.writeBool(self.is_admin_op)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.STRUCT, 4)
      self.privilege.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.role_name is None:
      raise TProtocol.TProtocolException(message='Required field role_name is unset!')
    if self.is_admin_op is None:
      raise TProtocol.TProtocolException(message='Required field is_admin_op is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetFunctionsParams:
  """
  Attributes:
   - category
   - db
   - pattern
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'category', None, None, ), # 1
    (2, TType.STRING, 'db', None, None, ), # 2
    (3, TType.STRING, 'pattern', None, None, ), # 3
    (4, TType.STRUCT, 'session', (ImpalaInternalService.ttypes.TSessionState, ImpalaInternalService.ttypes.TSessionState.thrift_spec), None, ), # 4
  )

  def __init__(self, category=None, db=None, pattern=None, session=None,):
    self.category = category
    self.db = db
    self.pattern = pattern
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.category = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.session = ImpalaInternalService.ttypes.TSessionState()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetFunctionsParams')
    if self.category is not None:
      oprot.writeFieldBegin('category', TType.I32, 1)
      oprot.writeI32(self.category)
      oprot.writeFieldEnd()
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 2)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 3)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 4)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.category is None:
      raise TProtocol.TProtocolException(message='Required field category is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetFunctionsResult:
  """
  Attributes:
   - fn_signatures
   - fn_ret_types
   - fn_binary_types
   - fn_persistence
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fn_signatures', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'fn_ret_types', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'fn_binary_types', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'fn_persistence', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, fn_signatures=None, fn_ret_types=None, fn_binary_types=None, fn_persistence=None,):
    self.fn_signatures = fn_signatures
    self.fn_ret_types = fn_ret_types
    self.fn_binary_types = fn_binary_types
    self.fn_persistence = fn_persistence

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fn_signatures = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readString();
            self.fn_signatures.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.fn_ret_types = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = iprot.readString();
            self.fn_ret_types.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.fn_binary_types = []
          (_etype92, _size89) = iprot.readListBegin()
          for _i93 in xrange(_size89):
            _elem94 = iprot.readString();
            self.fn_binary_types.append(_elem94)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fn_persistence = []
          (_etype98, _size95) = iprot.readListBegin()
          for _i99 in xrange(_size95):
            _elem100 = iprot.readString();
            self.fn_persistence.append(_elem100)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetFunctionsResult')
    if self.fn_signatures is not None:
      oprot.writeFieldBegin('fn_signatures', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.fn_signatures))
      for iter101 in self.fn_signatures:
        oprot.writeString(iter101)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fn_ret_types is not None:
      oprot.writeFieldBegin('fn_ret_types', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.fn_ret_types))
      for iter102 in self.fn_ret_types:
        oprot.writeString(iter102)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fn_binary_types is not None:
      oprot.writeFieldBegin('fn_binary_types', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.fn_binary_types))
      for iter103 in self.fn_binary_types:
        oprot.writeString(iter103)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fn_persistence is not None:
      oprot.writeFieldBegin('fn_persistence', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.fn_persistence))
      for iter104 in self.fn_persistence:
        oprot.writeString(iter104)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUseDbParams:
  """
  Attributes:
   - db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
  )

  def __init__(self, db=None,):
    self.db = db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUseDbParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db is None:
      raise TProtocol.TProtocolException(message='Required field db is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExplainResult:
  """
  Attributes:
   - results
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'results', (TType.STRUCT,(Data.ttypes.TResultRow, Data.ttypes.TResultRow.thrift_spec)), None, ), # 1
  )

  def __init__(self, results=None,):
    self.results = results

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.results = []
          (_etype108, _size105) = iprot.readListBegin()
          for _i109 in xrange(_size105):
            _elem110 = Data.ttypes.TResultRow()
            _elem110.read(iprot)
            self.results.append(_elem110)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExplainResult')
    if self.results is not None:
      oprot.writeFieldBegin('results', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.results))
      for iter111 in self.results:
        iter111.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.results is None:
      raise TProtocol.TProtocolException(message='Required field results is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TFinalizeParams:
  """
  Attributes:
   - is_overwrite
   - hdfs_base_dir
   - table_name
   - table_db
   - staging_dir
   - table_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_overwrite', None, None, ), # 1
    (2, TType.STRING, 'hdfs_base_dir', None, None, ), # 2
    (3, TType.STRING, 'table_name', None, None, ), # 3
    (4, TType.STRING, 'table_db', None, None, ), # 4
    (5, TType.STRING, 'staging_dir', None, None, ), # 5
    (6, TType.I64, 'table_id', None, None, ), # 6
  )

  def __init__(self, is_overwrite=None, hdfs_base_dir=None, table_name=None, table_db=None, staging_dir=None, table_id=None,):
    self.is_overwrite = is_overwrite
    self.hdfs_base_dir = hdfs_base_dir
    self.table_name = table_name
    self.table_db = table_db
    self.staging_dir = staging_dir
    self.table_id = table_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_overwrite = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.hdfs_base_dir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.table_db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.staging_dir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.table_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TFinalizeParams')
    if self.is_overwrite is not None:
      oprot.writeFieldBegin('is_overwrite', TType.BOOL, 1)
      oprot.writeBool(self.is_overwrite)
      oprot.writeFieldEnd()
    if self.hdfs_base_dir is not None:
      oprot.writeFieldBegin('hdfs_base_dir', TType.STRING, 2)
      oprot.writeString(self.hdfs_base_dir)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 3)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 4)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    if self.staging_dir is not None:
      oprot.writeFieldBegin('staging_dir', TType.STRING, 5)
      oprot.writeString(self.staging_dir)
      oprot.writeFieldEnd()
    if self.table_id is not None:
      oprot.writeFieldBegin('table_id', TType.I64, 6)
      oprot.writeI64(self.table_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.is_overwrite is None:
      raise TProtocol.TProtocolException(message='Required field is_overwrite is unset!')
    if self.hdfs_base_dir is None:
      raise TProtocol.TProtocolException(message='Required field hdfs_base_dir is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.table_db is None:
      raise TProtocol.TProtocolException(message='Required field table_db is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLoadDataReq:
  """
  Attributes:
   - table_name
   - source_path
   - overwrite
   - partition_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.STRING, 'source_path', None, None, ), # 2
    (3, TType.BOOL, 'overwrite', None, None, ), # 3
    (4, TType.LIST, 'partition_spec', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec)), None, ), # 4
  )

  def __init__(self, table_name=None, source_path=None, overwrite=None, partition_spec=None,):
    self.table_name = table_name
    self.source_path = source_path
    self.overwrite = overwrite
    self.partition_spec = partition_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.source_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.overwrite = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype115, _size112) = iprot.readListBegin()
          for _i116 in xrange(_size112):
            _elem117 = CatalogObjects.ttypes.TPartitionKeyValue()
            _elem117.read(iprot)
            self.partition_spec.append(_elem117)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLoadDataReq')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.source_path is not None:
      oprot.writeFieldBegin('source_path', TType.STRING, 2)
      oprot.writeString(self.source_path)
      oprot.writeFieldEnd()
    if self.overwrite is not None:
      oprot.writeFieldBegin('overwrite', TType.BOOL, 3)
      oprot.writeBool(self.overwrite)
      oprot.writeFieldEnd()
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter118 in self.partition_spec:
        iter118.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.source_path is None:
      raise TProtocol.TProtocolException(message='Required field source_path is unset!')
    if self.overwrite is None:
      raise TProtocol.TProtocolException(message='Required field overwrite is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLoadDataResp:
  """
  Attributes:
   - load_summary
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'load_summary', (Data.ttypes.TResultRow, Data.ttypes.TResultRow.thrift_spec), None, ), # 1
  )

  def __init__(self, load_summary=None,):
    self.load_summary = load_summary

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.load_summary = Data.ttypes.TResultRow()
          self.load_summary.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLoadDataResp')
    if self.load_summary is not None:
      oprot.writeFieldBegin('load_summary', TType.STRUCT, 1)
      self.load_summary.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.load_summary is None:
      raise TProtocol.TProtocolException(message='Required field load_summary is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanExecInfo:
  """
  Attributes:
   - fragments
   - per_node_scan_ranges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fragments', (TType.STRUCT,(Planner.ttypes.TPlanFragment, Planner.ttypes.TPlanFragment.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'per_node_scan_ranges', (TType.I32,None,TType.LIST,(TType.STRUCT,(Planner.ttypes.TScanRangeLocationList, Planner.ttypes.TScanRangeLocationList.thrift_spec))), None, ), # 2
  )

  def __init__(self, fragments=None, per_node_scan_ranges=None,):
    self.fragments = fragments
    self.per_node_scan_ranges = per_node_scan_ranges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fragments = []
          (_etype122, _size119) = iprot.readListBegin()
          for _i123 in xrange(_size119):
            _elem124 = Planner.ttypes.TPlanFragment()
            _elem124.read(iprot)
            self.fragments.append(_elem124)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.per_node_scan_ranges = {}
          (_ktype126, _vtype127, _size125 ) = iprot.readMapBegin() 
          for _i129 in xrange(_size125):
            _key130 = iprot.readI32();
            _val131 = []
            (_etype135, _size132) = iprot.readListBegin()
            for _i136 in xrange(_size132):
              _elem137 = Planner.ttypes.TScanRangeLocationList()
              _elem137.read(iprot)
              _val131.append(_elem137)
            iprot.readListEnd()
            self.per_node_scan_ranges[_key130] = _val131
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanExecInfo')
    if self.fragments is not None:
      oprot.writeFieldBegin('fragments', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.fragments))
      for iter138 in self.fragments:
        iter138.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.per_node_scan_ranges is not None:
      oprot.writeFieldBegin('per_node_scan_ranges', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.per_node_scan_ranges))
      for kiter139,viter140 in self.per_node_scan_ranges.items():
        oprot.writeI32(kiter139)
        oprot.writeListBegin(TType.STRUCT, len(viter140))
        for iter141 in viter140:
          iter141.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fragments is None:
      raise TProtocol.TProtocolException(message='Required field fragments is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TQueryExecRequest:
  """
  Attributes:
   - plan_exec_info
   - result_set_metadata
   - finalize_params
   - query_ctx
   - query_plan
   - stmt_type
   - host_list
   - lineage_graph
   - per_host_mem_estimate
   - max_per_host_min_reservation
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'plan_exec_info', (TType.STRUCT,(TPlanExecInfo, TPlanExecInfo.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'result_set_metadata', (Results.ttypes.TResultSetMetadata, Results.ttypes.TResultSetMetadata.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'finalize_params', (TFinalizeParams, TFinalizeParams.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'query_ctx', (ImpalaInternalService.ttypes.TQueryCtx, ImpalaInternalService.ttypes.TQueryCtx.thrift_spec), None, ), # 4
    (5, TType.STRING, 'query_plan', None, None, ), # 5
    (6, TType.I32, 'stmt_type', None, None, ), # 6
    (7, TType.LIST, 'host_list', (TType.STRUCT,(Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec)), None, ), # 7
    (8, TType.STRUCT, 'lineage_graph', (LineageGraph.ttypes.TLineageGraph, LineageGraph.ttypes.TLineageGraph.thrift_spec), None, ), # 8
    (9, TType.I64, 'per_host_mem_estimate', None, None, ), # 9
    (10, TType.I64, 'max_per_host_min_reservation', None, None, ), # 10
  )

  def __init__(self, plan_exec_info=None, result_set_metadata=None, finalize_params=None, query_ctx=None, query_plan=None, stmt_type=None, host_list=None, lineage_graph=None, per_host_mem_estimate=None, max_per_host_min_reservation=None,):
    self.plan_exec_info = plan_exec_info
    self.result_set_metadata = result_set_metadata
    self.finalize_params = finalize_params
    self.query_ctx = query_ctx
    self.query_plan = query_plan
    self.stmt_type = stmt_type
    self.host_list = host_list
    self.lineage_graph = lineage_graph
    self.per_host_mem_estimate = per_host_mem_estimate
    self.max_per_host_min_reservation = max_per_host_min_reservation

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.plan_exec_info = []
          (_etype145, _size142) = iprot.readListBegin()
          for _i146 in xrange(_size142):
            _elem147 = TPlanExecInfo()
            _elem147.read(iprot)
            self.plan_exec_info.append(_elem147)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.result_set_metadata = Results.ttypes.TResultSetMetadata()
          self.result_set_metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.finalize_params = TFinalizeParams()
          self.finalize_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.query_ctx = ImpalaInternalService.ttypes.TQueryCtx()
          self.query_ctx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.query_plan = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.stmt_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.host_list = []
          (_etype151, _size148) = iprot.readListBegin()
          for _i152 in xrange(_size148):
            _elem153 = Types.ttypes.TNetworkAddress()
            _elem153.read(iprot)
            self.host_list.append(_elem153)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.lineage_graph = LineageGraph.ttypes.TLineageGraph()
          self.lineage_graph.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.per_host_mem_estimate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.max_per_host_min_reservation = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TQueryExecRequest')
    if self.plan_exec_info is not None:
      oprot.writeFieldBegin('plan_exec_info', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.plan_exec_info))
      for iter154 in self.plan_exec_info:
        iter154.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.result_set_metadata is not None:
      oprot.writeFieldBegin('result_set_metadata', TType.STRUCT, 2)
      self.result_set_metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.finalize_params is not None:
      oprot.writeFieldBegin('finalize_params', TType.STRUCT, 3)
      self.finalize_params.write(oprot)
      oprot.writeFieldEnd()
    if self.query_ctx is not None:
      oprot.writeFieldBegin('query_ctx', TType.STRUCT, 4)
      self.query_ctx.write(oprot)
      oprot.writeFieldEnd()
    if self.query_plan is not None:
      oprot.writeFieldBegin('query_plan', TType.STRING, 5)
      oprot.writeString(self.query_plan)
      oprot.writeFieldEnd()
    if self.stmt_type is not None:
      oprot.writeFieldBegin('stmt_type', TType.I32, 6)
      oprot.writeI32(self.stmt_type)
      oprot.writeFieldEnd()
    if self.host_list is not None:
      oprot.writeFieldBegin('host_list', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.host_list))
      for iter155 in self.host_list:
        iter155.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.lineage_graph is not None:
      oprot.writeFieldBegin('lineage_graph', TType.STRUCT, 8)
      self.lineage_graph.write(oprot)
      oprot.writeFieldEnd()
    if self.per_host_mem_estimate is not None:
      oprot.writeFieldBegin('per_host_mem_estimate', TType.I64, 9)
      oprot.writeI64(self.per_host_mem_estimate)
      oprot.writeFieldEnd()
    if self.max_per_host_min_reservation is not None:
      oprot.writeFieldBegin('max_per_host_min_reservation', TType.I64, 10)
      oprot.writeI64(self.max_per_host_min_reservation)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.query_ctx is None:
      raise TProtocol.TProtocolException(message='Required field query_ctx is unset!')
    if self.stmt_type is None:
      raise TProtocol.TProtocolException(message='Required field stmt_type is unset!')
    if self.host_list is None:
      raise TProtocol.TProtocolException(message='Required field host_list is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCatalogOpRequest:
  """
  Attributes:
   - op_type
   - use_db_params
   - describe_db_params
   - describe_table_params
   - show_dbs_params
   - show_tables_params
   - show_fns_params
   - show_data_srcs_params
   - show_roles_params
   - show_grant_role_params
   - ddl_params
   - reset_metadata_params
   - show_stats_params
   - show_create_table_params
   - show_files_params
   - lineage_graph
   - show_create_function_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'op_type', None, None, ), # 1
    (2, TType.STRUCT, 'use_db_params', (TUseDbParams, TUseDbParams.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'describe_table_params', (TDescribeTableParams, TDescribeTableParams.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'show_dbs_params', (TShowDbsParams, TShowDbsParams.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'show_tables_params', (TShowTablesParams, TShowTablesParams.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'show_fns_params', (TShowFunctionsParams, TShowFunctionsParams.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'ddl_params', (CatalogService.ttypes.TDdlExecRequest, CatalogService.ttypes.TDdlExecRequest.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'reset_metadata_params', (CatalogService.ttypes.TResetMetadataRequest, CatalogService.ttypes.TResetMetadataRequest.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'show_stats_params', (TShowStatsParams, TShowStatsParams.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'show_create_table_params', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'show_data_srcs_params', (TShowDataSrcsParams, TShowDataSrcsParams.thrift_spec), None, ), # 11
    (12, TType.STRUCT, 'show_roles_params', (TShowRolesParams, TShowRolesParams.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'show_grant_role_params', (TShowGrantRoleParams, TShowGrantRoleParams.thrift_spec), None, ), # 13
    (14, TType.STRUCT, 'show_files_params', (TShowFilesParams, TShowFilesParams.thrift_spec), None, ), # 14
    (15, TType.STRUCT, 'lineage_graph', (LineageGraph.ttypes.TLineageGraph, LineageGraph.ttypes.TLineageGraph.thrift_spec), None, ), # 15
    (16, TType.STRUCT, 'show_create_function_params', (TGetFunctionsParams, TGetFunctionsParams.thrift_spec), None, ), # 16
    (17, TType.STRUCT, 'describe_db_params', (TDescribeDbParams, TDescribeDbParams.thrift_spec), None, ), # 17
  )

  def __init__(self, op_type=None, use_db_params=None, describe_db_params=None, describe_table_params=None, show_dbs_params=None, show_tables_params=None, show_fns_params=None, show_data_srcs_params=None, show_roles_params=None, show_grant_role_params=None, ddl_params=None, reset_metadata_params=None, show_stats_params=None, show_create_table_params=None, show_files_params=None, lineage_graph=None, show_create_function_params=None,):
    self.op_type = op_type
    self.use_db_params = use_db_params
    self.describe_db_params = describe_db_params
    self.describe_table_params = describe_table_params
    self.show_dbs_params = show_dbs_params
    self.show_tables_params = show_tables_params
    self.show_fns_params = show_fns_params
    self.show_data_srcs_params = show_data_srcs_params
    self.show_roles_params = show_roles_params
    self.show_grant_role_params = show_grant_role_params
    self.ddl_params = ddl_params
    self.reset_metadata_params = reset_metadata_params
    self.show_stats_params = show_stats_params
    self.show_create_table_params = show_create_table_params
    self.show_files_params = show_files_params
    self.lineage_graph = lineage_graph
    self.show_create_function_params = show_create_function_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.op_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.use_db_params = TUseDbParams()
          self.use_db_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.describe_db_params = TDescribeDbParams()
          self.describe_db_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.describe_table_params = TDescribeTableParams()
          self.describe_table_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.show_dbs_params = TShowDbsParams()
          self.show_dbs_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.show_tables_params = TShowTablesParams()
          self.show_tables_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.show_fns_params = TShowFunctionsParams()
          self.show_fns_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.show_data_srcs_params = TShowDataSrcsParams()
          self.show_data_srcs_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.show_roles_params = TShowRolesParams()
          self.show_roles_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.show_grant_role_params = TShowGrantRoleParams()
          self.show_grant_role_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.ddl_params = CatalogService.ttypes.TDdlExecRequest()
          self.ddl_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.reset_metadata_params = CatalogService.ttypes.TResetMetadataRequest()
          self.reset_metadata_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.show_stats_params = TShowStatsParams()
          self.show_stats_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.show_create_table_params = CatalogObjects.ttypes.TTableName()
          self.show_create_table_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.show_files_params = TShowFilesParams()
          self.show_files_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.lineage_graph = LineageGraph.ttypes.TLineageGraph()
          self.lineage_graph.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.show_create_function_params = TGetFunctionsParams()
          self.show_create_function_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCatalogOpRequest')
    if self.op_type is not None:
      oprot.writeFieldBegin('op_type', TType.I32, 1)
      oprot.writeI32(self.op_type)
      oprot.writeFieldEnd()
    if self.use_db_params is not None:
      oprot.writeFieldBegin('use_db_params', TType.STRUCT, 2)
      self.use_db_params.write(oprot)
      oprot.writeFieldEnd()
    if self.describe_table_params is not None:
      oprot.writeFieldBegin('describe_table_params', TType.STRUCT, 3)
      self.describe_table_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_dbs_params is not None:
      oprot.writeFieldBegin('show_dbs_params', TType.STRUCT, 4)
      self.show_dbs_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_tables_params is not None:
      oprot.writeFieldBegin('show_tables_params', TType.STRUCT, 5)
      self.show_tables_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_fns_params is not None:
      oprot.writeFieldBegin('show_fns_params', TType.STRUCT, 6)
      self.show_fns_params.write(oprot)
      oprot.writeFieldEnd()
    if self.ddl_params is not None:
      oprot.writeFieldBegin('ddl_params', TType.STRUCT, 7)
      self.ddl_params.write(oprot)
      oprot.writeFieldEnd()
    if self.reset_metadata_params is not None:
      oprot.writeFieldBegin('reset_metadata_params', TType.STRUCT, 8)
      self.reset_metadata_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_stats_params is not None:
      oprot.writeFieldBegin('show_stats_params', TType.STRUCT, 9)
      self.show_stats_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_create_table_params is not None:
      oprot.writeFieldBegin('show_create_table_params', TType.STRUCT, 10)
      self.show_create_table_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_data_srcs_params is not None:
      oprot.writeFieldBegin('show_data_srcs_params', TType.STRUCT, 11)
      self.show_data_srcs_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_roles_params is not None:
      oprot.writeFieldBegin('show_roles_params', TType.STRUCT, 12)
      self.show_roles_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_grant_role_params is not None:
      oprot.writeFieldBegin('show_grant_role_params', TType.STRUCT, 13)
      self.show_grant_role_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_files_params is not None:
      oprot.writeFieldBegin('show_files_params', TType.STRUCT, 14)
      self.show_files_params.write(oprot)
      oprot.writeFieldEnd()
    if self.lineage_graph is not None:
      oprot.writeFieldBegin('lineage_graph', TType.STRUCT, 15)
      self.lineage_graph.write(oprot)
      oprot.writeFieldEnd()
    if self.show_create_function_params is not None:
      oprot.writeFieldBegin('show_create_function_params', TType.STRUCT, 16)
      self.show_create_function_params.write(oprot)
      oprot.writeFieldEnd()
    if self.describe_db_params is not None:
      oprot.writeFieldBegin('describe_db_params', TType.STRUCT, 17)
      self.describe_db_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_type is None:
      raise TProtocol.TProtocolException(message='Required field op_type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSetQueryOptionRequest:
  """
  Attributes:
   - key
   - value
   - is_set_all
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
    (3, TType.BOOL, 'is_set_all', None, None, ), # 3
  )

  def __init__(self, key=None, value=None, is_set_all=None,):
    self.key = key
    self.value = value
    self.is_set_all = is_set_all

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_set_all = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSetQueryOptionRequest')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.is_set_all is not None:
      oprot.writeFieldBegin('is_set_all', TType.BOOL, 3)
      oprot.writeBool(self.is_set_all)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TMetadataOpRequest:
  """
  Attributes:
   - opcode
   - get_info_req
   - get_type_info_req
   - get_catalogs_req
   - get_schemas_req
   - get_tables_req
   - get_table_types_req
   - get_columns_req
   - get_functions_req
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'opcode', None, None, ), # 1
    (2, TType.STRUCT, 'get_info_req', (TCLIService.ttypes.TGetInfoReq, TCLIService.ttypes.TGetInfoReq.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'get_type_info_req', (TCLIService.ttypes.TGetTypeInfoReq, TCLIService.ttypes.TGetTypeInfoReq.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'get_catalogs_req', (TCLIService.ttypes.TGetCatalogsReq, TCLIService.ttypes.TGetCatalogsReq.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'get_schemas_req', (TCLIService.ttypes.TGetSchemasReq, TCLIService.ttypes.TGetSchemasReq.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'get_tables_req', (TCLIService.ttypes.TGetTablesReq, TCLIService.ttypes.TGetTablesReq.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'get_table_types_req', (TCLIService.ttypes.TGetTableTypesReq, TCLIService.ttypes.TGetTableTypesReq.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'get_columns_req', (TCLIService.ttypes.TGetColumnsReq, TCLIService.ttypes.TGetColumnsReq.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'get_functions_req', (TCLIService.ttypes.TGetFunctionsReq, TCLIService.ttypes.TGetFunctionsReq.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'session', (ImpalaInternalService.ttypes.TSessionState, ImpalaInternalService.ttypes.TSessionState.thrift_spec), None, ), # 10
  )

  def __init__(self, opcode=None, get_info_req=None, get_type_info_req=None, get_catalogs_req=None, get_schemas_req=None, get_tables_req=None, get_table_types_req=None, get_columns_req=None, get_functions_req=None, session=None,):
    self.opcode = opcode
    self.get_info_req = get_info_req
    self.get_type_info_req = get_type_info_req
    self.get_catalogs_req = get_catalogs_req
    self.get_schemas_req = get_schemas_req
    self.get_tables_req = get_tables_req
    self.get_table_types_req = get_table_types_req
    self.get_columns_req = get_columns_req
    self.get_functions_req = get_functions_req
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.opcode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.get_info_req = TCLIService.ttypes.TGetInfoReq()
          self.get_info_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.get_type_info_req = TCLIService.ttypes.TGetTypeInfoReq()
          self.get_type_info_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.get_catalogs_req = TCLIService.ttypes.TGetCatalogsReq()
          self.get_catalogs_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.get_schemas_req = TCLIService.ttypes.TGetSchemasReq()
          self.get_schemas_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.get_tables_req = TCLIService.ttypes.TGetTablesReq()
          self.get_tables_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.get_table_types_req = TCLIService.ttypes.TGetTableTypesReq()
          self.get_table_types_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.get_columns_req = TCLIService.ttypes.TGetColumnsReq()
          self.get_columns_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.get_functions_req = TCLIService.ttypes.TGetFunctionsReq()
          self.get_functions_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.session = ImpalaInternalService.ttypes.TSessionState()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TMetadataOpRequest')
    if self.opcode is not None:
      oprot.writeFieldBegin('opcode', TType.I32, 1)
      oprot.writeI32(self.opcode)
      oprot.writeFieldEnd()
    if self.get_info_req is not None:
      oprot.writeFieldBegin('get_info_req', TType.STRUCT, 2)
      self.get_info_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_type_info_req is not None:
      oprot.writeFieldBegin('get_type_info_req', TType.STRUCT, 3)
      self.get_type_info_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_catalogs_req is not None:
      oprot.writeFieldBegin('get_catalogs_req', TType.STRUCT, 4)
      self.get_catalogs_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_schemas_req is not None:
      oprot.writeFieldBegin('get_schemas_req', TType.STRUCT, 5)
      self.get_schemas_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_tables_req is not None:
      oprot.writeFieldBegin('get_tables_req', TType.STRUCT, 6)
      self.get_tables_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_table_types_req is not None:
      oprot.writeFieldBegin('get_table_types_req', TType.STRUCT, 7)
      self.get_table_types_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_columns_req is not None:
      oprot.writeFieldBegin('get_columns_req', TType.STRUCT, 8)
      self.get_columns_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_functions_req is not None:
      oprot.writeFieldBegin('get_functions_req', TType.STRUCT, 9)
      self.get_functions_req.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 10)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.opcode is None:
      raise TProtocol.TProtocolException(message='Required field opcode is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAccessEvent:
  """
  Attributes:
   - name
   - object_type
   - privilege
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'object_type', None, None, ), # 2
    (3, TType.STRING, 'privilege', None, None, ), # 3
  )

  def __init__(self, name=None, object_type=None, privilege=None,):
    self.name = name
    self.object_type = object_type
    self.privilege = privilege

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.object_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.privilege = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAccessEvent')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.object_type is not None:
      oprot.writeFieldBegin('object_type', TType.I32, 2)
      oprot.writeI32(self.object_type)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.STRING, 3)
      oprot.writeString(self.privilege)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.object_type is None:
      raise TProtocol.TProtocolException(message='Required field object_type is unset!')
    if self.privilege is None:
      raise TProtocol.TProtocolException(message='Required field privilege is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExecRequest:
  """
  Attributes:
   - stmt_type
   - query_options
   - query_exec_request
   - catalog_op_request
   - result_set_metadata
   - explain_result
   - load_data_request
   - access_events
   - analysis_warnings
   - set_query_option_request
   - timeline
   - user_has_profile_access
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'stmt_type', None, None, ), # 1
    (2, TType.STRUCT, 'query_options', (ImpalaInternalService.ttypes.TQueryOptions, ImpalaInternalService.ttypes.TQueryOptions.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'query_exec_request', (TQueryExecRequest, TQueryExecRequest.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'catalog_op_request', (TCatalogOpRequest, TCatalogOpRequest.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'result_set_metadata', (Results.ttypes.TResultSetMetadata, Results.ttypes.TResultSetMetadata.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'explain_result', (TExplainResult, TExplainResult.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'load_data_request', (TLoadDataReq, TLoadDataReq.thrift_spec), None, ), # 7
    (8, TType.SET, 'access_events', (TType.STRUCT,(TAccessEvent, TAccessEvent.thrift_spec)), None, ), # 8
    (9, TType.LIST, 'analysis_warnings', (TType.STRING,None), None, ), # 9
    (10, TType.STRUCT, 'set_query_option_request', (TSetQueryOptionRequest, TSetQueryOptionRequest.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'timeline', (RuntimeProfile.ttypes.TEventSequence, RuntimeProfile.ttypes.TEventSequence.thrift_spec), None, ), # 11
    (12, TType.BOOL, 'user_has_profile_access', None, None, ), # 12
  )

  def __init__(self, stmt_type=None, query_options=None, query_exec_request=None, catalog_op_request=None, result_set_metadata=None, explain_result=None, load_data_request=None, access_events=None, analysis_warnings=None, set_query_option_request=None, timeline=None, user_has_profile_access=None,):
    self.stmt_type = stmt_type
    self.query_options = query_options
    self.query_exec_request = query_exec_request
    self.catalog_op_request = catalog_op_request
    self.result_set_metadata = result_set_metadata
    self.explain_result = explain_result
    self.load_data_request = load_data_request
    self.access_events = access_events
    self.analysis_warnings = analysis_warnings
    self.set_query_option_request = set_query_option_request
    self.timeline = timeline
    self.user_has_profile_access = user_has_profile_access

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.stmt_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.query_options = ImpalaInternalService.ttypes.TQueryOptions()
          self.query_options.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.query_exec_request = TQueryExecRequest()
          self.query_exec_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.catalog_op_request = TCatalogOpRequest()
          self.catalog_op_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.result_set_metadata = Results.ttypes.TResultSetMetadata()
          self.result_set_metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.explain_result = TExplainResult()
          self.explain_result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.load_data_request = TLoadDataReq()
          self.load_data_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.SET:
          self.access_events = set()
          (_etype159, _size156) = iprot.readSetBegin()
          for _i160 in xrange(_size156):
            _elem161 = TAccessEvent()
            _elem161.read(iprot)
            self.access_events.add(_elem161)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.analysis_warnings = []
          (_etype165, _size162) = iprot.readListBegin()
          for _i166 in xrange(_size162):
            _elem167 = iprot.readString();
            self.analysis_warnings.append(_elem167)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.set_query_option_request = TSetQueryOptionRequest()
          self.set_query_option_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.timeline = RuntimeProfile.ttypes.TEventSequence()
          self.timeline.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.user_has_profile_access = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExecRequest')
    if self.stmt_type is not None:
      oprot.writeFieldBegin('stmt_type', TType.I32, 1)
      oprot.writeI32(self.stmt_type)
      oprot.writeFieldEnd()
    if self.query_options is not None:
      oprot.writeFieldBegin('query_options', TType.STRUCT, 2)
      self.query_options.write(oprot)
      oprot.writeFieldEnd()
    if self.query_exec_request is not None:
      oprot.writeFieldBegin('query_exec_request', TType.STRUCT, 3)
      self.query_exec_request.write(oprot)
      oprot.writeFieldEnd()
    if self.catalog_op_request is not None:
      oprot.writeFieldBegin('catalog_op_request', TType.STRUCT, 4)
      self.catalog_op_request.write(oprot)
      oprot.writeFieldEnd()
    if self.result_set_metadata is not None:
      oprot.writeFieldBegin('result_set_metadata', TType.STRUCT, 5)
      self.result_set_metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.explain_result is not None:
      oprot.writeFieldBegin('explain_result', TType.STRUCT, 6)
      self.explain_result.write(oprot)
      oprot.writeFieldEnd()
    if self.load_data_request is not None:
      oprot.writeFieldBegin('load_data_request', TType.STRUCT, 7)
      self.load_data_request.write(oprot)
      oprot.writeFieldEnd()
    if self.access_events is not None:
      oprot.writeFieldBegin('access_events', TType.SET, 8)
      oprot.writeSetBegin(TType.STRUCT, len(self.access_events))
      for iter168 in self.access_events:
        iter168.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.analysis_warnings is not None:
      oprot.writeFieldBegin('analysis_warnings', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.analysis_warnings))
      for iter169 in self.analysis_warnings:
        oprot.writeString(iter169)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.set_query_option_request is not None:
      oprot.writeFieldBegin('set_query_option_request', TType.STRUCT, 10)
      self.set_query_option_request.write(oprot)
      oprot.writeFieldEnd()
    if self.timeline is not None:
      oprot.writeFieldBegin('timeline', TType.STRUCT, 11)
      self.timeline.write(oprot)
      oprot.writeFieldEnd()
    if self.user_has_profile_access is not None:
      oprot.writeFieldBegin('user_has_profile_access', TType.BOOL, 12)
      oprot.writeBool(self.user_has_profile_access)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.stmt_type is None:
      raise TProtocol.TProtocolException(message='Required field stmt_type is unset!')
    if self.query_options is None:
      raise TProtocol.TProtocolException(message='Required field query_options is unset!')
    if self.analysis_warnings is None:
      raise TProtocol.TProtocolException(message='Required field analysis_warnings is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCacheJarParams:
  """
  Attributes:
   - hdfs_location
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hdfs_location', None, None, ), # 1
  )

  def __init__(self, hdfs_location=None,):
    self.hdfs_location = hdfs_location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hdfs_location = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCacheJarParams')
    if self.hdfs_location is not None:
      oprot.writeFieldBegin('hdfs_location', TType.STRING, 1)
      oprot.writeString(self.hdfs_location)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.hdfs_location is None:
      raise TProtocol.TProtocolException(message='Required field hdfs_location is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCacheJarResult:
  """
  Attributes:
   - status
   - local_path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
    (2, TType.STRING, 'local_path', None, None, ), # 2
  )

  def __init__(self, status=None, local_path=None,):
    self.status = status
    self.local_path = local_path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.local_path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCacheJarResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.local_path is not None:
      oprot.writeFieldBegin('local_path', TType.STRING, 2)
      oprot.writeString(self.local_path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSymbolLookupParams:
  """
  Attributes:
   - location
   - symbol
   - fn_binary_type
   - arg_types
   - has_var_args
   - ret_arg_type
   - symbol_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'location', None, None, ), # 1
    (2, TType.STRING, 'symbol', None, None, ), # 2
    (3, TType.I32, 'fn_binary_type', None, None, ), # 3
    (4, TType.LIST, 'arg_types', (TType.STRUCT,(Types.ttypes.TColumnType, Types.ttypes.TColumnType.thrift_spec)), None, ), # 4
    (5, TType.BOOL, 'has_var_args', None, None, ), # 5
    (6, TType.STRUCT, 'ret_arg_type', (Types.ttypes.TColumnType, Types.ttypes.TColumnType.thrift_spec), None, ), # 6
    (7, TType.I32, 'symbol_type', None, None, ), # 7
  )

  def __init__(self, location=None, symbol=None, fn_binary_type=None, arg_types=None, has_var_args=None, ret_arg_type=None, symbol_type=None,):
    self.location = location
    self.symbol = symbol
    self.fn_binary_type = fn_binary_type
    self.arg_types = arg_types
    self.has_var_args = has_var_args
    self.ret_arg_type = ret_arg_type
    self.symbol_type = symbol_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.symbol = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.fn_binary_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.arg_types = []
          (_etype173, _size170) = iprot.readListBegin()
          for _i174 in xrange(_size170):
            _elem175 = Types.ttypes.TColumnType()
            _elem175.read(iprot)
            self.arg_types.append(_elem175)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.has_var_args = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.ret_arg_type = Types.ttypes.TColumnType()
          self.ret_arg_type.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.symbol_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSymbolLookupParams')
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 1)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.symbol is not None:
      oprot.writeFieldBegin('symbol', TType.STRING, 2)
      oprot.writeString(self.symbol)
      oprot.writeFieldEnd()
    if self.fn_binary_type is not None:
      oprot.writeFieldBegin('fn_binary_type', TType.I32, 3)
      oprot.writeI32(self.fn_binary_type)
      oprot.writeFieldEnd()
    if self.arg_types is not None:
      oprot.writeFieldBegin('arg_types', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.arg_types))
      for iter176 in self.arg_types:
        iter176.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.has_var_args is not None:
      oprot.writeFieldBegin('has_var_args', TType.BOOL, 5)
      oprot.writeBool(self.has_var_args)
      oprot.writeFieldEnd()
    if self.ret_arg_type is not None:
      oprot.writeFieldBegin('ret_arg_type', TType.STRUCT, 6)
      self.ret_arg_type.write(oprot)
      oprot.writeFieldEnd()
    if self.symbol_type is not None:
      oprot.writeFieldBegin('symbol_type', TType.I32, 7)
      oprot.writeI32(self.symbol_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.location is None:
      raise TProtocol.TProtocolException(message='Required field location is unset!')
    if self.symbol is None:
      raise TProtocol.TProtocolException(message='Required field symbol is unset!')
    if self.fn_binary_type is None:
      raise TProtocol.TProtocolException(message='Required field fn_binary_type is unset!')
    if self.arg_types is None:
      raise TProtocol.TProtocolException(message='Required field arg_types is unset!')
    if self.has_var_args is None:
      raise TProtocol.TProtocolException(message='Required field has_var_args is unset!')
    if self.symbol_type is None:
      raise TProtocol.TProtocolException(message='Required field symbol_type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSymbolLookupResult:
  """
  Attributes:
   - result_code
   - symbol
   - error_msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'result_code', None, None, ), # 1
    (2, TType.STRING, 'symbol', None, None, ), # 2
    (3, TType.STRING, 'error_msg', None, None, ), # 3
  )

  def __init__(self, result_code=None, symbol=None, error_msg=None,):
    self.result_code = result_code
    self.symbol = symbol
    self.error_msg = error_msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.result_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.symbol = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.error_msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSymbolLookupResult')
    if self.result_code is not None:
      oprot.writeFieldBegin('result_code', TType.I32, 1)
      oprot.writeI32(self.result_code)
      oprot.writeFieldEnd()
    if self.symbol is not None:
      oprot.writeFieldBegin('symbol', TType.STRING, 2)
      oprot.writeString(self.symbol)
      oprot.writeFieldEnd()
    if self.error_msg is not None:
      oprot.writeFieldBegin('error_msg', TType.STRING, 3)
      oprot.writeString(self.error_msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.result_code is None:
      raise TProtocol.TProtocolException(message='Required field result_code is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUpdateCatalogCacheRequest:
  """
  Attributes:
   - is_delta
   - catalog_service_id
   - updated_objects
   - removed_objects
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_delta', None, None, ), # 1
    (2, TType.STRUCT, 'catalog_service_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.LIST, 'updated_objects', (TType.STRUCT,(CatalogObjects.ttypes.TCatalogObject, CatalogObjects.ttypes.TCatalogObject.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'removed_objects', (TType.STRUCT,(CatalogObjects.ttypes.TCatalogObject, CatalogObjects.ttypes.TCatalogObject.thrift_spec)), None, ), # 4
  )

  def __init__(self, is_delta=None, catalog_service_id=None, updated_objects=None, removed_objects=None,):
    self.is_delta = is_delta
    self.catalog_service_id = catalog_service_id
    self.updated_objects = updated_objects
    self.removed_objects = removed_objects

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_delta = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.catalog_service_id = Types.ttypes.TUniqueId()
          self.catalog_service_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.updated_objects = []
          (_etype180, _size177) = iprot.readListBegin()
          for _i181 in xrange(_size177):
            _elem182 = CatalogObjects.ttypes.TCatalogObject()
            _elem182.read(iprot)
            self.updated_objects.append(_elem182)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.removed_objects = []
          (_etype186, _size183) = iprot.readListBegin()
          for _i187 in xrange(_size183):
            _elem188 = CatalogObjects.ttypes.TCatalogObject()
            _elem188.read(iprot)
            self.removed_objects.append(_elem188)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUpdateCatalogCacheRequest')
    if self.is_delta is not None:
      oprot.writeFieldBegin('is_delta', TType.BOOL, 1)
      oprot.writeBool(self.is_delta)
      oprot.writeFieldEnd()
    if self.catalog_service_id is not None:
      oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 2)
      self.catalog_service_id.write(oprot)
      oprot.writeFieldEnd()
    if self.updated_objects is not None:
      oprot.writeFieldBegin('updated_objects', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.updated_objects))
      for iter189 in self.updated_objects:
        iter189.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.removed_objects is not None:
      oprot.writeFieldBegin('removed_objects', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.removed_objects))
      for iter190 in self.removed_objects:
        iter190.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.is_delta is None:
      raise TProtocol.TProtocolException(message='Required field is_delta is unset!')
    if self.catalog_service_id is None:
      raise TProtocol.TProtocolException(message='Required field catalog_service_id is unset!')
    if self.updated_objects is None:
      raise TProtocol.TProtocolException(message='Required field updated_objects is unset!')
    if self.removed_objects is None:
      raise TProtocol.TProtocolException(message='Required field removed_objects is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUpdateCatalogCacheResponse:
  """
  Attributes:
   - catalog_service_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'catalog_service_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 1
  )

  def __init__(self, catalog_service_id=None,):
    self.catalog_service_id = catalog_service_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.catalog_service_id = Types.ttypes.TUniqueId()
          self.catalog_service_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUpdateCatalogCacheResponse')
    if self.catalog_service_id is not None:
      oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 1)
      self.catalog_service_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.catalog_service_id is None:
      raise TProtocol.TProtocolException(message='Required field catalog_service_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUpdateMembershipRequest:
  """
  Attributes:
   - hostnames
   - ip_addresses
   - num_nodes
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'hostnames', (TType.STRING,None), None, ), # 1
    (2, TType.SET, 'ip_addresses', (TType.STRING,None), None, ), # 2
    (3, TType.I32, 'num_nodes', None, None, ), # 3
  )

  def __init__(self, hostnames=None, ip_addresses=None, num_nodes=None,):
    self.hostnames = hostnames
    self.ip_addresses = ip_addresses
    self.num_nodes = num_nodes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.hostnames = set()
          (_etype194, _size191) = iprot.readSetBegin()
          for _i195 in xrange(_size191):
            _elem196 = iprot.readString();
            self.hostnames.add(_elem196)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.ip_addresses = set()
          (_etype200, _size197) = iprot.readSetBegin()
          for _i201 in xrange(_size197):
            _elem202 = iprot.readString();
            self.ip_addresses.add(_elem202)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.num_nodes = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUpdateMembershipRequest')
    if self.hostnames is not None:
      oprot.writeFieldBegin('hostnames', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.hostnames))
      for iter203 in self.hostnames:
        oprot.writeString(iter203)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ip_addresses is not None:
      oprot.writeFieldBegin('ip_addresses', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.ip_addresses))
      for iter204 in self.ip_addresses:
        oprot.writeString(iter204)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.num_nodes is not None:
      oprot.writeFieldBegin('num_nodes', TType.I32, 3)
      oprot.writeI32(self.num_nodes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.hostnames is None:
      raise TProtocol.TProtocolException(message='Required field hostnames is unset!')
    if self.ip_addresses is None:
      raise TProtocol.TProtocolException(message='Required field ip_addresses is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TJvmMemoryPool:
  """
  Attributes:
   - committed
   - init
   - max
   - used
   - peak_committed
   - peak_init
   - peak_max
   - peak_used
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'committed', None, None, ), # 1
    (2, TType.I64, 'init', None, None, ), # 2
    (3, TType.I64, 'max', None, None, ), # 3
    (4, TType.I64, 'used', None, None, ), # 4
    (5, TType.I64, 'peak_committed', None, None, ), # 5
    (6, TType.I64, 'peak_init', None, None, ), # 6
    (7, TType.I64, 'peak_max', None, None, ), # 7
    (8, TType.I64, 'peak_used', None, None, ), # 8
    (9, TType.STRING, 'name', None, None, ), # 9
  )

  def __init__(self, committed=None, init=None, max=None, used=None, peak_committed=None, peak_init=None, peak_max=None, peak_used=None, name=None,):
    self.committed = committed
    self.init = init
    self.max = max
    self.used = used
    self.peak_committed = peak_committed
    self.peak_init = peak_init
    self.peak_max = peak_max
    self.peak_used = peak_used
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.committed = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.init = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.max = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.used = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.peak_committed = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.peak_init = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.peak_max = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.peak_used = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TJvmMemoryPool')
    if self.committed is not None:
      oprot.writeFieldBegin('committed', TType.I64, 1)
      oprot.writeI64(self.committed)
      oprot.writeFieldEnd()
    if self.init is not None:
      oprot.writeFieldBegin('init', TType.I64, 2)
      oprot.writeI64(self.init)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I64, 3)
      oprot.writeI64(self.max)
      oprot.writeFieldEnd()
    if self.used is not None:
      oprot.writeFieldBegin('used', TType.I64, 4)
      oprot.writeI64(self.used)
      oprot.writeFieldEnd()
    if self.peak_committed is not None:
      oprot.writeFieldBegin('peak_committed', TType.I64, 5)
      oprot.writeI64(self.peak_committed)
      oprot.writeFieldEnd()
    if self.peak_init is not None:
      oprot.writeFieldBegin('peak_init', TType.I64, 6)
      oprot.writeI64(self.peak_init)
      oprot.writeFieldEnd()
    if self.peak_max is not None:
      oprot.writeFieldBegin('peak_max', TType.I64, 7)
      oprot.writeI64(self.peak_max)
      oprot.writeFieldEnd()
    if self.peak_used is not None:
      oprot.writeFieldBegin('peak_used', TType.I64, 8)
      oprot.writeI64(self.peak_used)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 9)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.committed is None:
      raise TProtocol.TProtocolException(message='Required field committed is unset!')
    if self.init is None:
      raise TProtocol.TProtocolException(message='Required field init is unset!')
    if self.max is None:
      raise TProtocol.TProtocolException(message='Required field max is unset!')
    if self.used is None:
      raise TProtocol.TProtocolException(message='Required field used is unset!')
    if self.peak_committed is None:
      raise TProtocol.TProtocolException(message='Required field peak_committed is unset!')
    if self.peak_init is None:
      raise TProtocol.TProtocolException(message='Required field peak_init is unset!')
    if self.peak_max is None:
      raise TProtocol.TProtocolException(message='Required field peak_max is unset!')
    if self.peak_used is None:
      raise TProtocol.TProtocolException(message='Required field peak_used is unset!')
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetJvmMetricsRequest:
  """
  Attributes:
   - get_all
   - memory_pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'get_all', None, None, ), # 1
    (2, TType.STRING, 'memory_pool', None, None, ), # 2
  )

  def __init__(self, get_all=None, memory_pool=None,):
    self.get_all = get_all
    self.memory_pool = memory_pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.get_all = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.memory_pool = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetJvmMetricsRequest')
    if self.get_all is not None:
      oprot.writeFieldBegin('get_all', TType.BOOL, 1)
      oprot.writeBool(self.get_all)
      oprot.writeFieldEnd()
    if self.memory_pool is not None:
      oprot.writeFieldBegin('memory_pool', TType.STRING, 2)
      oprot.writeString(self.memory_pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.get_all is None:
      raise TProtocol.TProtocolException(message='Required field get_all is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetJvmMetricsResponse:
  """
  Attributes:
   - memory_pools
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'memory_pools', (TType.STRUCT,(TJvmMemoryPool, TJvmMemoryPool.thrift_spec)), None, ), # 1
  )

  def __init__(self, memory_pools=None,):
    self.memory_pools = memory_pools

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.memory_pools = []
          (_etype208, _size205) = iprot.readListBegin()
          for _i209 in xrange(_size205):
            _elem210 = TJvmMemoryPool()
            _elem210.read(iprot)
            self.memory_pools.append(_elem210)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetJvmMetricsResponse')
    if self.memory_pools is not None:
      oprot.writeFieldBegin('memory_pools', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.memory_pools))
      for iter211 in self.memory_pools:
        iter211.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.memory_pools is None:
      raise TProtocol.TProtocolException(message='Required field memory_pools is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TJvmThreadInfo:
  """
  Attributes:
   - summary
   - cpu_time_in_ns
   - user_time_in_ns
   - blocked_count
   - blocked_time_in_ms
   - is_in_native
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'summary', None, None, ), # 1
    (2, TType.I64, 'cpu_time_in_ns', None, None, ), # 2
    (3, TType.I64, 'user_time_in_ns', None, None, ), # 3
    (4, TType.I64, 'blocked_count', None, None, ), # 4
    (5, TType.I64, 'blocked_time_in_ms', None, None, ), # 5
    (6, TType.BOOL, 'is_in_native', None, None, ), # 6
  )

  def __init__(self, summary=None, cpu_time_in_ns=None, user_time_in_ns=None, blocked_count=None, blocked_time_in_ms=None, is_in_native=None,):
    self.summary = summary
    self.cpu_time_in_ns = cpu_time_in_ns
    self.user_time_in_ns = user_time_in_ns
    self.blocked_count = blocked_count
    self.blocked_time_in_ms = blocked_time_in_ms
    self.is_in_native = is_in_native

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.summary = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.cpu_time_in_ns = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.user_time_in_ns = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.blocked_count = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.blocked_time_in_ms = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.is_in_native = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TJvmThreadInfo')
    if self.summary is not None:
      oprot.writeFieldBegin('summary', TType.STRING, 1)
      oprot.writeString(self.summary)
      oprot.writeFieldEnd()
    if self.cpu_time_in_ns is not None:
      oprot.writeFieldBegin('cpu_time_in_ns', TType.I64, 2)
      oprot.writeI64(self.cpu_time_in_ns)
      oprot.writeFieldEnd()
    if self.user_time_in_ns is not None:
      oprot.writeFieldBegin('user_time_in_ns', TType.I64, 3)
      oprot.writeI64(self.user_time_in_ns)
      oprot.writeFieldEnd()
    if self.blocked_count is not None:
      oprot.writeFieldBegin('blocked_count', TType.I64, 4)
      oprot.writeI64(self.blocked_count)
      oprot.writeFieldEnd()
    if self.blocked_time_in_ms is not None:
      oprot.writeFieldBegin('blocked_time_in_ms', TType.I64, 5)
      oprot.writeI64(self.blocked_time_in_ms)
      oprot.writeFieldEnd()
    if self.is_in_native is not None:
      oprot.writeFieldBegin('is_in_native', TType.BOOL, 6)
      oprot.writeBool(self.is_in_native)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.summary is None:
      raise TProtocol.TProtocolException(message='Required field summary is unset!')
    if self.cpu_time_in_ns is None:
      raise TProtocol.TProtocolException(message='Required field cpu_time_in_ns is unset!')
    if self.user_time_in_ns is None:
      raise TProtocol.TProtocolException(message='Required field user_time_in_ns is unset!')
    if self.blocked_count is None:
      raise TProtocol.TProtocolException(message='Required field blocked_count is unset!')
    if self.blocked_time_in_ms is None:
      raise TProtocol.TProtocolException(message='Required field blocked_time_in_ms is unset!')
    if self.is_in_native is None:
      raise TProtocol.TProtocolException(message='Required field is_in_native is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetJvmThreadsInfoRequest:
  """
  Attributes:
   - get_complete_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'get_complete_info', None, None, ), # 1
  )

  def __init__(self, get_complete_info=None,):
    self.get_complete_info = get_complete_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.get_complete_info = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetJvmThreadsInfoRequest')
    if self.get_complete_info is not None:
      oprot.writeFieldBegin('get_complete_info', TType.BOOL, 1)
      oprot.writeBool(self.get_complete_info)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.get_complete_info is None:
      raise TProtocol.TProtocolException(message='Required field get_complete_info is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetJvmThreadsInfoResponse:
  """
  Attributes:
   - total_thread_count
   - daemon_thread_count
   - peak_thread_count
   - threads
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'total_thread_count', None, None, ), # 1
    (2, TType.I32, 'daemon_thread_count', None, None, ), # 2
    (3, TType.I32, 'peak_thread_count', None, None, ), # 3
    (4, TType.LIST, 'threads', (TType.STRUCT,(TJvmThreadInfo, TJvmThreadInfo.thrift_spec)), None, ), # 4
  )

  def __init__(self, total_thread_count=None, daemon_thread_count=None, peak_thread_count=None, threads=None,):
    self.total_thread_count = total_thread_count
    self.daemon_thread_count = daemon_thread_count
    self.peak_thread_count = peak_thread_count
    self.threads = threads

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.total_thread_count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.daemon_thread_count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.peak_thread_count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.threads = []
          (_etype215, _size212) = iprot.readListBegin()
          for _i216 in xrange(_size212):
            _elem217 = TJvmThreadInfo()
            _elem217.read(iprot)
            self.threads.append(_elem217)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetJvmThreadsInfoResponse')
    if self.total_thread_count is not None:
      oprot.writeFieldBegin('total_thread_count', TType.I32, 1)
      oprot.writeI32(self.total_thread_count)
      oprot.writeFieldEnd()
    if self.daemon_thread_count is not None:
      oprot.writeFieldBegin('daemon_thread_count', TType.I32, 2)
      oprot.writeI32(self.daemon_thread_count)
      oprot.writeFieldEnd()
    if self.peak_thread_count is not None:
      oprot.writeFieldBegin('peak_thread_count', TType.I32, 3)
      oprot.writeI32(self.peak_thread_count)
      oprot.writeFieldEnd()
    if self.threads is not None:
      oprot.writeFieldBegin('threads', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.threads))
      for iter218 in self.threads:
        iter218.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.total_thread_count is None:
      raise TProtocol.TProtocolException(message='Required field total_thread_count is unset!')
    if self.daemon_thread_count is None:
      raise TProtocol.TProtocolException(message='Required field daemon_thread_count is unset!')
    if self.peak_thread_count is None:
      raise TProtocol.TProtocolException(message='Required field peak_thread_count is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetHadoopConfigRequest:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetHadoopConfigRequest')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetHadoopConfigResponse:
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetHadoopConfigResponse')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetAllHadoopConfigsResponse:
  """
  Attributes:
   - configs
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'configs', (TType.STRING,None,TType.STRING,None), None, ), # 1
  )

  def __init__(self, configs=None,):
    self.configs = configs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.configs = {}
          (_ktype220, _vtype221, _size219 ) = iprot.readMapBegin() 
          for _i223 in xrange(_size219):
            _key224 = iprot.readString();
            _val225 = iprot.readString();
            self.configs[_key224] = _val225
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetAllHadoopConfigsResponse')
    if self.configs is not None:
      oprot.writeFieldBegin('configs', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configs))
      for kiter226,viter227 in self.configs.items():
        oprot.writeString(kiter226)
        oprot.writeString(viter227)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TBuildTestDescriptorTableParams:
  """
  Attributes:
   - slot_types
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'slot_types', (TType.LIST,(TType.STRUCT,(Types.ttypes.TColumnType, Types.ttypes.TColumnType.thrift_spec))), None, ), # 1
  )

  def __init__(self, slot_types=None,):
    self.slot_types = slot_types

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.slot_types = []
          (_etype231, _size228) = iprot.readListBegin()
          for _i232 in xrange(_size228):
            _elem233 = []
            (_etype237, _size234) = iprot.readListBegin()
            for _i238 in xrange(_size234):
              _elem239 = Types.ttypes.TColumnType()
              _elem239.read(iprot)
              _elem233.append(_elem239)
            iprot.readListEnd()
            self.slot_types.append(_elem233)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TBuildTestDescriptorTableParams')
    if self.slot_types is not None:
      oprot.writeFieldBegin('slot_types', TType.LIST, 1)
      oprot.writeListBegin(TType.LIST, len(self.slot_types))
      for iter240 in self.slot_types:
        oprot.writeListBegin(TType.STRUCT, len(iter240))
        for iter241 in iter240:
          iter241.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.slot_types is None:
      raise TProtocol.TProtocolException(message='Required field slot_types is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
